# AUTOGENERATED from harvest.sh (probes_cli_main.sh)
# Part 5 - Final section (probes, usage, main)

# ----- Probes (read-only) -----
probe_cjdns_admin() {
  local out
  out="$(run_cmd_capture "cjdns_ping" cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec ping)"
  echo "$out" | jq -e '.q=="pong"' >/dev/null 2>&1 || return 1
  return 0
}

probe_my_cjdns_ip() {
  # Core_nodeInfo is the canonical place on your build: has myIp6
  local json
  json="$(run_cmd_capture "nodeInfo" cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec Core_nodeInfo)"
  echo "$json" | jq -r '.myIp6 // "NA"'
}

probe_router_status() {
  [[ "$SHOW_ROUTER_STATUS" == "yes" ]] || return 0

  print_section "CJDNS Router"

  # Show our cjdns IPv6
  local nodeinfo myip
  nodeinfo="$(run_cmd_capture "nodeinfo" cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec Core_nodeInfo)"
  myip="$(echo "$nodeinfo" | jq -r '.myIp6 // "NA"')"
  echo "  MyIP=$myip"

  # InterfaceController_peerStats is paged: must loop --page=N while .more==1
  local page=0 more=1 j all
  all='[]'
  while :; do
    j="$(run_cmd_capture "peerstats_p$page" cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec InterfaceController_peerStats --page="$page")" || break
    # merge peers into array
    all="$(jq -cs '.[0] + (.[1].peers // [])' <(printf '%s' "$all") <(printf '%s' "$j"))"
    more="$(printf '%s' "$j" | jq -r '.more // 0')"
    [[ "$more" == "1" ]] || break
    page=$((page+1))
  done
  local established unresponsive total
  established="$(printf '%s\n' "$all" | jq '[.[] | select(.state=="ESTABLISHED")] | length')"
  unresponsive="$(printf '%s\n' "$all" | jq '[.[] | select(.state=="UNRESPONSIVE")] | length')"
  total="$(printf '%s\n' "$all" | jq 'length')"

  echo "  Established=$established  Unresponsive=$unresponsive  Total=$total"

  if [[ "$SHOW_ROUTER_ESTABLISHED_LIST" == "yes" ]]; then
  echo "  Established peers:"
  # Print raw lladdr from jq, then normalize in bash so IPv6 doesn't get chopped.
  printf '%s\n' "$all" | jq -r '
    .[]
    | select(.state=="ESTABLISHED")
    | [
        (.lladdr // "NA"),
        (if ((.isIncoming // 0)|tonumber)==1 then "IN" else "OUT" end),
        ("in " + ((.recvKbps//0)|tostring) + "kb/s"),
        ("out " + ((.sendKbps//0)|tostring) + "kb/s"),
        ("LOS=" + ((.lostPackets//0)|tostring)),
        ("OOR=" + ((.receivedOutOfRange//0)|tostring)),
        (if ((.isAllowed//0)|tonumber)!=0 then "seeded_peer" else "" end)
      ]
    | map(select(.!=""))
    | @tsv
  ' | while IFS=$'\t' read -r lladdr dir ink outk los oor seeded; do
    host="$(cjdns_host_from_maybe_bracketed "$lladdr")"
    # rebuild line pieces (some fields may be empty depending on seeded flag)
    line="    ${host}  ${dir}"
    [[ -n "${ink:-}"    ]] && line="${line}  ${ink}"
    [[ -n "${outk:-}"   ]] && line="${line}  ${outk}"
    [[ -n "${los:-}"    ]] && line="${line}  ${los}"
    [[ -n "${oor:-}"    ]] && line="${line}  ${oor}"
    [[ -n "${seeded:-}" ]] && line="${line}  ${seeded}"
    printf "%s\n" "$line"
  done | head -n 200
  fi

  if [[ "$SHOW_ROUTER_UNRESPONSIVE_LIST" == "yes" ]]; then
  echo "  Unresponsive peers:"
  # Print raw lladdr then normalize in bash so IPv6 doesn't get chopped.
  printf '%s\n' "$all" | jq -r '
    .[]
    | select(.state=="UNRESPONSIVE")
    | (.lladdr // "NA")
  ' | while IFS= read -r lladdr; do
    host="$(cjdns_host_from_maybe_bracketed "$lladdr")"
    printf "    %s\n" "$host"
  done | head -n 200
  fi
}

probe_core_peers() {
  [[ "$SHOW_CORE_PEERS" == "yes" ]] || return 0

  local peers
  peers="$(run_cmd_capture_json "getpeerinfo" bash -lc "$CLI getpeerinfo")"
  if ! cjdh_json_must_start "getpeerinfo" "$peers"; then
    log_warn "getpeerinfo not JSON; skipping core peer snapshot this loop."
    return 0
  fi

  local total inb outb
  total="$(echo "$peers" | jq '[.[] | select(.network=="cjdns")] | length')"
  inb="$(echo "$peers" | jq '[.[] | select(.network=="cjdns" and .inbound==true)] | length')"
  outb="$(echo "$peers" | jq '[.[] | select(.network=="cjdns" and .inbound==false)] | length')"

  echo
  echo "Bitcoin Core (cjdns)"
  echo "  Connected=$total  inbound=$inb outbound=$outb"

  echo "$peers" | jq -r '
    .[]
    | select(.network=="cjdns")
    | (if .inbound then "IN" else "OUT" end) + "\t" + .addr
  ' | while IFS=$'\t' read -r dir addr; do
    host="$(cjdns_host_from_maybe_bracketed "$addr")"
    printf "    %-3s RAW=%s  HOST=%s\n" "$dir" "$addr" "$host"
  done | head -n 200
}



probe_addrman_cjdns() {
  echo
  echo "Addrman (cjdns)"
  local j total
  j="$(run_cmd_capture "addrman_cjdns" bash -lc "$CLI getnodeaddresses 0 cjdns")" || {
    echo "  (addrman query failed)"
    return 0
  }

  total="$(echo "$j" | jq 'length')"
  echo "  TOTAL=$total"

  if (( total > 0 )); then
    # host-only for DB logic later; keep it simple here
    echo "$j" | jq -r '.[]? | .address' | head -n 50 | sed 's/^/  /'
  fi
}

probe_nodestore_page0() {
  [[ "$HARVEST_NODESTORE" == "yes" ]] || return 0
  echo
  echo "NodeStore (page 0 sanity)"
  local json
  json="$(run_cmd_capture "nodestore_p0" cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec NodeStore_dumpTable --page=0)"

  local more entries first_ip first_path first_host
  more="$(echo "$json" | jq -r '(.more//0)')"
  entries="$(echo "$json" | jq -r '(.routingTable|length)')"
  first_ip="$(echo "$json" | jq -r '(.routingTable[0].ip // "NA")')"
  first_path="$(echo "$json" | jq -r '(.routingTable[0].path // "NA")')"
  first_host="$(cjdns_host_from_maybe_bracketed "$first_ip")"

  echo "  more=$more  entries=$entries"
  echo "  first_ip_raw=$first_ip"
  echo "  first_ip_host=$first_host"
  echo "  first_path=$first_path"

  if [[ "$SHOW_NODESTORE_PAGE_NUMBERS" == "yes" ]]; then
    echo "  (page numbers enabled; full harvest will show: page 0, page 1, ...)"
  fi
  if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
    echo "$json" | jq -r '.routingTable[]?.ip' | head -n 60 | sed 's/^/  ip: /'
  fi
}

usage() {
  cat <<'USG'
Usage:
    harvest.sh --print-config    Print current config values (loaded from harvest.conf if present)
  harvest.sh --run             Phase 4: ingest + onetry attempts + verification

Notes:
  - No harvesting/onetry in Phase 2.
  
v4 Changes:
  - Color-coded status indicators (+ PONG, >> CONNECTED, xx NOT-SEEN, etc.)
  - Optimized getpeerinfo: single call per loop (was 3-4)
  - Enhanced visual hierarchy with section headers
USG
}

main() {
  # NOARGS_GUARD_V5: no options => show help (do not run anything)
  if [[ $# -eq 0 ]]; then
    usage
    return 1
  fi

  mkdir -p "$BASE_DIR"


  case "${1:-}" in
    --help|-h) usage; exit 0 ;;
--print-config)
      load_conf_if_present
      print_config
      exit 0
      ;;
--run)
      LOOP_NUM=0
      WIZARD_MODE="run"
      setup

      load_conf
      # PREFLIGHT_HOOK_V5
      preflight_run || exit 1
      dbg_init
      db_init

    while true; do
      if (( HARVEST_STOP_REQUESTED )); then
        log_info "Stopped." || true
        exit 0
      fi
      if ! run_phase4; then
        log_warn "run_phase4 failed (rc=$?). Continuing to next scan." || true
      fi
      if (( HARVEST_STOP_REQUESTED )); then
        log_info "Stopped." || true
        exit 0
      fi
      sleep_with_optional_countdown "${SCAN_SLEEP_SEC:-20}"
    done
    ;;

    *)
    echo "[ERR ] Unknown arg: ${1:-}" >&2
      usage
      exit 2
      ;;
  esac
}
