# AUTOGENERATED from harvest.sh (bootstrap_ui_dbconf.sh)

# v5 modular: BASE_DIR is owned by the loader (harvest.sh)
if [[ -n "${CJDH_ROOT:-}" ]]; then
  BASE_DIR="$CJDH_ROOT"
fi

# v5 safety: ensure sane PATH for non-interactive shells
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
set -u
set -o pipefail

# ========================================================================
# ANSI Color Definitions
# ========================================================================
C_RESET='\033[0m'
C_BOLD='\033[1m'
C_DIM='\033[2m'
C_GREEN='\033[38;5;108m'      # Calm green (connected)
C_YELLOW='\033[38;5;179m'     # Calm yellow (pending)
C_GRAY='\033[38;5;245m'       # Gray (no response)
C_BRED='\033[38;5;203m'       # Bright red (failures/unexpected)
C_BGREEN='\033[38;5;120m'     # Bright green (success highlights)
C_HEADER='\033[1;36m'         # Bold cyan for section headers
C_PINK='\033[38;5;205m'         # Pink for OUT peers
C_NAVY='\033[38;5;27m'          # Navy blue for IN peers
C_DULL_RED='\033[38;5;167m'      # Dull red (unharvested)
C_BRIGHT_RED='\033[38;5;196m'    # Bright red (new addresses)
C_LIGHT_GRAY='\033[38;5;250m'    # Light gray (already harvested)
C_LIGHT_RED='\033[38;5;210m'     # Light red (new=0)
C_DULL_RED='\033[38;5;167m'      # Dull red (unharvested)
C_BRIGHT_RED='\033[38;5;196m'    # Bright red (new addresses)
C_LIGHT_GRAY='\033[38;5;250m'    # Light gray (already harvested)

# ========================================================================
# UI Helper Functions
# ========================================================================
print_box() {
    local title="$1"
    local width=70
    printf "${C_HEADER}"
    printf '╔'
    printf '═%.0s' $(seq 1 $width)
    printf '╗\n'
    printf "║ %-${width}s ║\n" "$title"
    printf '╚'
    printf '═%.0s' $(seq 1 $width)
    printf '╝\n'
    printf "${C_RESET}"
}

print_section() {
    local title="$1"
    printf "\n${C_BOLD}${C_HEADER}▶ %s${C_RESET}\n" "$title"
}

status_pong_ok() {
    printf "${C_GREEN}+ PONG${C_RESET}"
}

status_pong_fail() {
    printf "${C_GRAY}- NO-PONG${C_RESET}"
}

status_connected() {
    printf "${C_GREEN}>> CONNECTED${C_RESET}"
}

status_not_seen() {
    printf "${C_BRED}xx NOT-SEEN${C_RESET}"
}

status_dispatched() {
    printf "${C_YELLOW}.. DISPATCHED${C_RESET}"
}

status_new_peer() {
    printf "${C_BRED}!! NEW-PEER${C_RESET}"
}

show_progress() {
    printf "${C_DIM}%s...${C_RESET}" "$1"
}

# ========================================================================
# Graceful shutdown handling
# ========================================================================
HARVEST_STOP_REQUESTED=0
HARVEST_SIGINT_COUNT=0
request_stop() {
  # Trap handler for INT/TERM.
  # INT: 1st Ctrl+C => graceful stop, 2nd Ctrl+C => immediate exit 130.
  # TERM: always request stop (and let the loop exit).
  local sig="${1:-INT}"

  HARVEST_STOP_REQUESTED=1

  if [[ "$sig" == "INT" ]]; then
    HARVEST_SIGINT_COUNT=$(( ${HARVEST_SIGINT_COUNT:-0} + 1 ))
    if (( HARVEST_SIGINT_COUNT >= 2 )); then
      echo "$(date +%F\ %T) [WARN] Second Ctrl+C: exiting immediately." >&2
        tmp_cleanup_now || true
      exit 130
    fi
  fi

  log_warn "Stop requested ($sig). Finishing current step then exiting." || true
}
trap 'request_stop INT' INT
trap 'request_stop TERM' TERM

# cjdnsharvestv3
# Phase 2: config wizard + DB init + read-only probes (NO harvesting / NO onetry yet)

# ----- Defaults (Enter-through expected) -----
SCAN_SLEEP_SEC_DEFAULT=20
ONETRY_GAP_SEC_DEFAULT=0
MAX_ATTEMPTS_PER_LOOP_DEFAULT=0       # 0 => unlimited (future use)

# Onetry verification wording (for later phases; no onetry yet in Phase 2)
ONETRY_VERIFY_MODE_DEFAULT="wait"     # wait|delay
ONETRY_VERIFY_TIMEOUT_SEC_DEFAULT=5   # used when mode=wait
ONETRY_VERIFY_DELAY_SEC_DEFAULT=0     # used when mode=delay

HARVEST_NODESTORE_DEFAULT="yes"

  # Remote NodeStore (optional, SSH to another cjdns node)
  HARVEST_REMOTE_NODESTORE_DEFAULT="no"
  REMOTE_NODESTORE_HOST_DEFAULT=""
  REMOTE_NODESTORE_USER_DEFAULT=""
SHOW_NODESTORE_PAGE_NUMBERS_DEFAULT="yes"
SHOW_NODESTORE_PAGE_SUMMARY_DEFAULT="yes"
SHOW_NODESTORE_IPS_DEFAULT="no"

SHOW_ROUTER_STATUS_DEFAULT="yes"
SHOW_ROUTER_ESTABLISHED_LIST_DEFAULT="yes"
SHOW_ROUTER_UNRESPONSIVE_LIST_DEFAULT="no"

SHOW_CORE_PEERS_DEFAULT="yes"

PING_ENABLE_DEFAULT="yes"
PING_TIMEOUT_SEC_DEFAULT=3

  # cjdns admin (used by cjdnstool cexec/Frontier/NodeStore)
  CJDNS_ADMIN_ADDR_DEFAULT="127.0.0.1"
  CJDNS_ADMIN_PORT_DEFAULT="11234"

RETRY_TRIED_EVERY_LOOPS_DEFAULT=0
RECHECK_CONFIRMED_EVERY_LOOPS_DEFAULT=0
RECHECK_CONFIRMED_MAX_PER_LOOP_DEFAULT="0"  # 0=use MAX_ATTEMPTS_PER_LOOP; if that is 0 then no cap

COMPACT_DASHBOARD_DEFAULT="no"
COUNTDOWN_SLEEP_DEFAULT="yes"

  # Bitcoin Core auto-detect defaults (overridden by harvest.conf)
  BITCOIN_CLI_BIN_DEFAULT="bitcoin-cli"
  BITCOIN_DATADIR_DEFAULT="${HOME}/.bitcoin"
  BITCOIN_CONF_DEFAULT="${HOME}/.bitcoin/bitcoin.conf"

  # cjdns admin defaults (overridden by harvest.conf)
  CJDNS_ADMIN_ADDR_DEFAULT="127.0.0.1"
  CJDNS_ADMIN_PORT_DEFAULT="11234"

# ----- Paths -----
# BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"   # disabled: loader owns BASE_DIR

# v5 modules
# [[ -f "$BASE_DIR/lib/preflight.sh" ]] && source "$BASE_DIR/lib/preflight.sh"   # disabled: loader already sources these
# [[ -f "$BASE_DIR/lib/frontier.sh"  ]] && source "$BASE_DIR/lib/frontier.sh"   # disabled: loader already sources these
CONF_PATH="$BASE_DIR/harvest.conf"
DB_PATH="$BASE_DIR/state.db"

# ----- Temp files (all under one folder; cleared each loop) -----
TMPBASE="/tmp/cjdnsharvesttmpfileswithasuperlongfilenamewhichwillalwaysbedeletedattheendofeachrunthebeginningofeachrunandwhenterminatedwithctrlcthesecondpress"
TMPDIR="${TMPBASE}"
tmp_reset_loop() {
  # Hard reset the ONE temp folder (silent + safe)
  rm -rf "$TMPBASE" 2>/dev/null || true
  mkdir -p "$TMPBASE" 2>/dev/null || true
}
tmp_cleanup_now() {
  rm -rf "$TMPBASE" 2>/dev/null || true
}

# Always delete temp folder on any exit (silent)
trap 'tmp_cleanup_now || true' EXIT
finalize_stale_attempts() {
  # If we Ctrl-C mid-loop, batch attempts can be left in last_result="attempt".
  # Resolve old ones to fail so the DB doesn't get stuck in 'attempt' state forever.
  # This does NOT block future retries; it's just cleanup.
  local stale_after="${1:-600}"   # seconds

  local now n
  now="$(date +%s)"

  n="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM attempts WHERE last_result='attempt' AND last_attempt_ts IS NOT NULL AND ($now - last_attempt_ts) > $stale_after;" 2>/dev/null || echo 0)"
  [[ "$n" =~ ^[0-9]+$ ]] || n=0
  if (( n <= 0 )); then
    return 0
  fi

  sqlite3 "$DB_PATH" <<SQL >/dev/null
UPDATE attempts
SET last_result='fail',
    last_fail_ts=COALESCE(last_attempt_ts, strftime('%s','now')),
    consecutive_fail=consecutive_fail+1
WHERE last_result='attempt'
  AND last_attempt_ts IS NOT NULL
  AND ($now - last_attempt_ts) > $stale_after;
SQL

  echo "Finalized stale attempts: $n (attempt→fail; stale>${stale_after}s)"
}

# Bitcoin Core CLI (your known-good wrapper)
# Bitcoin Core CLI (built from detected/saved vars)
  : "${BITCOIN_CLI_BIN:=${BITCOIN_CLI_BIN_DEFAULT:-bitcoin-cli}}"
  : "${BITCOIN_DATADIR:=${BITCOIN_DATADIR_DEFAULT:-$HOME/.bitcoin}}"
  : "${BITCOIN_CONF:=${BITCOIN_CONF_DEFAULT:-$BITCOIN_DATADIR/bitcoin.conf}}"
  CLI="$BITCOIN_CLI_BIN -datadir=$BITCOIN_DATADIR -conf=$BITCOIN_CONF"
# ----- Logging helpers -----
ts() { date '+%F %T'; }

num_sanitize() {
  # Turns any input into a safe integer (strips whitespace/newlines/non-digits). Default 0.
  local x="${1:-0}"
  x="${x//$'\r'/}"
  x="${x//$'\n'/}"
  x="${x//[!0-9]/}"
  [[ -n "$x" ]] || x=0
  printf '%s\n' "$x"
}

log_info() { printf '%s [INFO] %s\n' "$(ts)" "$*" >&2; }
log_warn() { printf '%s [WARN] %s\n' "$(ts)" "$*" >&2; }
log_err()  { printf '%s [ERR ] %s\n' "$(ts)" "$*" >&2; }
dbg_init() { :; }
# ----- DB helpers (sqlite3) -----
db_exec() {
  # Usage: db_exec "TAG" "SQL..."
  local tag="$1"; shift
  run_cmd_capture "$tag" sqlite3 "$DB_PATH" "$*" >/dev/null
}

db_query() {
  # Usage: db_query "TAG" "SQL..."
  local tag="$1"; shift
  run_cmd_capture "$tag" sqlite3 -noheader -batch "$DB_PATH" "$*"
}

# ----- Host normalization (IPv6 full/exploded form) -----
canon_host() {
  # Canonicalize an IP string for DB keys.
  # - Lowercase
  # - If bracketed like [fc00::1]:8333 => fc00::1
  # - If valid IP => IPv6 exploded (full) / IPv4 as-is
  # - If not an IP => returns lowercased original
  local raw="${1:-}"
  [[ -n "$raw" ]] || { echo ""; return 0; }
  python3 - <<'PY2' "$raw" 2>/dev/null || printf '%s\n' "${raw,,}"
import ipaddress, sys
h = (sys.argv[1] or "").strip().lower()

# Strip [addr]:port form safely
if h.startswith('['):
    h = h[1:]
if ']' in h:
    h = h.split(']')[0]

try:
    ip = ipaddress.ip_address(h)
    # exploded for v6 makes it "full"; v4 is already canonical enough
    print(ip.exploded if ip.version == 6 else str(ip))
except Exception:
    print(h)
PY2
}

db_migrate_fullip_if_needed() {
  # One-time migration: rewrite master/confirmed/attempts to canonical host keys.
  # Safe to run repeatedly; it will no-op once everything is canonical.
  [[ -f "$DB_PATH" ]] || return 0

  # If any IPv6 host looks non-canonical (has ::, uppercase A-F, or is shorter than 39 chars), migrate.
  local need=0
  need="$(sqlite3 "$DB_PATH" "
    SELECT CASE WHEN EXISTS(
      SELECT 1 FROM (
        SELECT host FROM master
        UNION ALL SELECT host FROM confirmed
        UNION ALL SELECT host FROM attempts
      )
      WHERE host LIKE '%:%'
        AND (
          host LIKE '%::%'
          OR host GLOB '*[A-F]*'
          OR length(host) < 39
        )
      LIMIT 1
    ) THEN 1 ELSE 0 END;
  " 2>/dev/null || echo 0)"

  [[ "$need" == "1" ]] || return 0

  log_warn "DB migration: canonicalizing host keys to full IPv6 form (one-time)."

  python3 - <<'PY3' "$DB_PATH"
import sqlite3, ipaddress, sys

db = sys.argv[1]
con = sqlite3.connect(db)
con.execute("PRAGMA foreign_keys=OFF;")
cur = con.cursor()

def canon(h: str):
    if h is None:
        return None
    h = h.strip().lower()
    # strip [addr]:port form
    if h.startswith('['):
        h = h[1:]
    if ']' in h:
        h = h.split(']')[0]
    try:
        ip = ipaddress.ip_address(h)
        return ip.exploded if ip.version == 6 else str(ip)
    except Exception:
        return h

cur.execute("BEGIN;")

# Create new tables (same schema)
cur.executescript("""
DROP TABLE IF EXISTS master_new;
DROP TABLE IF EXISTS confirmed_new;
DROP TABLE IF EXISTS attempts_new;

CREATE TABLE master_new (
  host TEXT PRIMARY KEY,
  first_seen_ts INTEGER NOT NULL,
  last_seen_ts INTEGER NOT NULL,
  source_flags TEXT NOT NULL DEFAULT ''
);

CREATE TABLE confirmed_new (
  host TEXT PRIMARY KEY,
  first_confirmed_ts INTEGER NOT NULL,
  last_confirmed_ts INTEGER NOT NULL,
  confirm_count INTEGER NOT NULL DEFAULT 1
);

CREATE TABLE attempts_new (
  host TEXT PRIMARY KEY,
  last_attempt_ts INTEGER,
  attempt_count INTEGER NOT NULL DEFAULT 0,
  last_result TEXT,
  last_fail_ts INTEGER,
  consecutive_fail INTEGER NOT NULL DEFAULT 0,
  cooldown_until_ts INTEGER
);
""")

# MASTER merge: min(first_seen), max(last_seen), union of source_flags tokens
acc = {}
for h, fst, lst, flags in cur.execute("SELECT host, first_seen_ts, last_seen_ts, source_flags FROM master;"):
    ch = canon(h)
    a = acc.setdefault(ch, {"fst": fst, "lst": lst, "flags": set()})
    a["fst"] = min(a["fst"], fst)
    a["lst"] = max(a["lst"], lst)
    for tok in (flags or "").split(","):
        tok = tok.strip()
        if tok:
            a["flags"].add(tok)

for ch, a in acc.items():
    cur.execute(
        "INSERT INTO master_new(host, first_seen_ts, last_seen_ts, source_flags) VALUES (?,?,?,?);",
        (ch, a["fst"], a["lst"], ",".join(sorted(a["flags"])))
    )

# CONFIRMED merge: min(first), max(last), sum(confirm_count)
acc = {}
for h, fst, lst, cnt in cur.execute("SELECT host, first_confirmed_ts, last_confirmed_ts, confirm_count FROM confirmed;"):
    ch = canon(h)
    a = acc.setdefault(ch, {"fst": fst, "lst": lst, "cnt": 0})
    a["fst"] = min(a["fst"], fst)
    a["lst"] = max(a["lst"], lst)
    a["cnt"] += int(cnt or 0)

for ch, a in acc.items():
    cur.execute(
        "INSERT INTO confirmed_new(host, first_confirmed_ts, last_confirmed_ts, confirm_count) VALUES (?,?,?,?);",
        (ch, a["fst"], a["lst"], a["cnt"] if a["cnt"] > 0 else 1)
    )

# ATTEMPTS merge: max(last_attempt_ts), sum(attempt_count), take last_result from newest last_attempt_ts if possible,
# max(last_fail_ts), max(consecutive_fail), max(cooldown_until_ts)
acc = {}
for row in cur.execute("SELECT host, last_attempt_ts, attempt_count, last_result, last_fail_ts, consecutive_fail, cooldown_until_ts FROM attempts;"):
    h, last_attempt, cnt, last_res, last_fail, cons_fail, cooldown = row
    ch = canon(h)
    a = acc.setdefault(ch, {
        "last_attempt": None,
        "attempt_count": 0,
        "last_result": None,
        "last_fail": None,
        "consecutive_fail": 0,
        "cooldown": None,
    })
    # last_attempt: keep max, and keep matching last_result for that max
    if last_attempt is not None:
        if a["last_attempt"] is None or int(last_attempt) > int(a["last_attempt"]):
            a["last_attempt"] = int(last_attempt)
            a["last_result"] = last_res
    a["attempt_count"] += int(cnt or 0)
    if last_fail is not None:
        a["last_fail"] = max(int(last_fail), int(a["last_fail"]) if a["last_fail"] is not None else int(last_fail))
    a["consecutive_fail"] = max(int(cons_fail or 0), int(a["consecutive_fail"] or 0))
    if cooldown is not None:
        a["cooldown"] = max(int(cooldown), int(a["cooldown"]) if a["cooldown"] is not None else int(cooldown))

for ch, a in acc.items():
    cur.execute(
        """INSERT INTO attempts_new(host,last_attempt_ts,attempt_count,last_result,last_fail_ts,consecutive_fail,cooldown_until_ts)
           VALUES (?,?,?,?,?,?,?);""",
        (ch, a["last_attempt"], a["attempt_count"], a["last_result"], a["last_fail"], a["consecutive_fail"], a["cooldown"])
    )

# Swap tables
cur.executescript("""
ALTER TABLE master RENAME TO master_old_fullip;
ALTER TABLE confirmed RENAME TO confirmed_old_fullip;
ALTER TABLE attempts RENAME TO attempts_old_fullip;

ALTER TABLE master_new RENAME TO master;
ALTER TABLE confirmed_new RENAME TO confirmed;
ALTER TABLE attempts_new RENAME TO attempts;
""")

con.commit()
con.close()
print("OK: full-ip canonical migration complete.")
PY3

  # Quick sanity
  sqlite3 "$DB_PATH" "PRAGMA integrity_check;" 2>/dev/null | head -n 1 || true
}

db_record_attempt() {
  # Usage: db_record_attempt "host"
  # Records a try into the canonical attempts table.
  # Does NOT create schema here (schema belongs to db_init_schema()).
  # Non-fatal if DB/table is missing in some modes.
  local host="${1:-}"
  [[ -n "$host" ]] || return 0
  host="$(canon_host "${host:-}")"
  host="$(canon_host "$host")"
  [[ -n "$host" ]] || return 0
  local ts
  ts="$(date +%s)"

  # Update attempts table if it exists; ignore errors quietly.
  sqlite3 "$DB_PATH" <<SQL >/dev/null 2>&1 || true
INSERT INTO attempts(host, last_attempt_ts, attempt_count, last_result)
VALUES ('$host', $ts, 1, 'attempt')
ON CONFLICT(host) DO UPDATE SET
  last_attempt_ts = excluded.last_attempt_ts,
  attempt_count   = attempts.attempt_count + 1,
  last_result     = 'attempt';
SQL
}

db_init_schema() {
  mkdir -p "$BASE_DIR"

  run_cmd_capture "sqlite_init" sqlite3 "$DB_PATH" <<'SQL' >/dev/null
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;

CREATE TABLE IF NOT EXISTS master (
  host TEXT PRIMARY KEY,
  first_seen_ts INTEGER NOT NULL,
  last_seen_ts INTEGER NOT NULL,
  source_flags TEXT NOT NULL DEFAULT ''
);

CREATE TABLE IF NOT EXISTS confirmed (
  host TEXT PRIMARY KEY,
  first_confirmed_ts INTEGER NOT NULL,
  last_confirmed_ts INTEGER NOT NULL,
  confirm_count INTEGER NOT NULL DEFAULT 1
);

CREATE TABLE IF NOT EXISTS attempts (
  host TEXT PRIMARY KEY,
  last_attempt_ts INTEGER,
  attempt_count INTEGER NOT NULL DEFAULT 0,
  last_result TEXT,
  last_fail_ts INTEGER,
  consecutive_fail INTEGER NOT NULL DEFAULT 0,
  cooldown_until_ts INTEGER
);

-- Migration: add cooldown_until_ts if this DB was created by an older schema
SQL
}

  # One-time: canonicalize IPv6 host keys (prevents shortened/full duplicates)
  db_migrate_fullip_if_needed || true


migrate_attempts_add_cooldown_until_ts() {
  # Add attempts.cooldown_until_ts if missing (safe on existing DBs).
  # SQLite lacks 'ADD COLUMN IF NOT EXISTS', so we probe table_info first.
  local has
  has="$(sqlite3 "$DB_PATH" "PRAGMA table_info(attempts);" 2>/dev/null | awk -F'|' '$2=="cooldown_until_ts"{print 1; exit}' || true)"
  if [[ "$has" != "1" ]]; then
    sqlite3 "$DB_PATH" "ALTER TABLE attempts ADD COLUMN cooldown_until_ts INTEGER;" >/dev/null 2>&1 || true
  fi
}

db_upsert_master() {
  # Usage: db_upsert_master host source
  local host src="$2"
  host="$(canon_host "${1:-}")"
  host="$(canon_host "$host")"
  [[ -n "$host" ]] || return 0
  local now
  now="$(date +%s)"
  sqlite3 "$DB_PATH" <<SQL >/dev/null
INSERT INTO master(host, first_seen_ts, last_seen_ts, source_flags)
VALUES ('$host', $now, $now, '$src')
ON CONFLICT(host) DO UPDATE SET
  last_seen_ts=excluded.last_seen_ts,
  source_flags=CASE
    WHEN instr(master.source_flags, '$src')>0 THEN master.source_flags
    WHEN master.source_flags=='' THEN '$src'
    ELSE master.source_flags || ',' || '$src'
  END;
SQL
}

db_upsert_confirmed() {
  # Usage: db_upsert_confirmed host
  local host
  host="$(canon_host "${1:-}")"
  host="$(canon_host "$host")"
  [[ -n "$host" ]] || return 0
  local now
  now="$(date +%s)"
  sqlite3 "$DB_PATH" <<SQL >/dev/null
INSERT INTO confirmed(host, first_confirmed_ts, last_confirmed_ts, confirm_count)
VALUES ('$host', $now, $now, 1)
ON CONFLICT(host) DO UPDATE SET
  last_confirmed_ts=excluded.last_confirmed_ts,
  confirm_count=confirm_count+1;
SQL
}

db_counts() {
  echo "  master=$(db_query count_master 'SELECT COUNT(*) FROM master;')  confirmed=$(db_query count_conf 'SELECT COUNT(*) FROM confirmed;')"
}

db_show_counts() {
  # Compatibility wrapper: older patches call db_show_counts, but this script uses db_counts.
  db_counts
}

db_next_loop_num() {
  # Persistent loop counter for "every N loops" retry knobs.
  # Returns the incremented loop number.
  local cur next
  cur="$(sqlite3 "$DB_PATH" "SELECT value FROM meta WHERE key='loop_num' LIMIT 1;" 2>/dev/null || true)"
  if [[ ! "$cur" =~ ^[0-9]+$ ]]; then
    cur=0
  fi
  next=$((cur+1))
  sqlite3 "$DB_PATH" <<SQL >/dev/null
INSERT INTO meta(key,value) VALUES('loop_num','$next')
ON CONFLICT(key) DO UPDATE SET value=excluded.value;
SQL
  printf '%s\n' "$next"
}

# ----- Validation helpers -----

sleep_with_optional_countdown() {
  local secs="${1:-0}"
  [[ "${secs:-0}" =~ ^[0-9]+$ ]] || secs=0
  if (( secs <= 0 )); then
    return 0
  fi

  if [[ "${COUNTDOWN_SLEEP:-yes}" == "yes" ]]; then
    echo "Sleeping ${secs}s (countdown):"
    local i="$secs"
    while (( i > 0 )); do
      printf "\r  %ds remaining... " "$i"
      sleep 1
      i=$((i-1))
    done
    printf "\r  done.            \n"
  else
    echo "Sleeping ${secs}s."
    sleep "$secs"
  fi
}

is_int() { [[ "${1:-}" =~ ^-?[0-9]+$ ]]; }

need_int_ge() {
  local name="${1:-}" val="${2:-}" min="${3:-0}"
  if [[ -z "$name" ]]; then
    log_err "need_int_ge: missing name"
    return 1
  fi
  if ! is_int "$val"; then
    log_err "$name must be an integer (got: '$val')"
    return 1
  fi
  if ! is_int "$min"; then
    log_err "need_int_ge: min must be integer (got: '$min')"
    return 1
  fi
  if (( val < min )); then
    log_err "$name must be >= $min (got: $val)"
    return 1
  fi
  return 0
}

need_int_range() {
  local name="$1" val="$2" min="$3" max="$4"
  need_int_ge "$name" "$val" "$min" || return 1
  if (( val > max )); then
    log_err "$name must be <= $max (got: $val)"
    return 1
  fi
  return 0
}

need_yesno() {
  local name="$1" val="${2:-}"
  case "$val" in
    yes|no) return 0 ;;
    *) log_err "$name must be 'yes' or 'no' (got: '$val')"; return 1 ;;
  esac
}

need_choice() {
  local name="$1" val="$2"; shift 2
  local ok="no"
  for c in "$@"; do [[ "$val" == "$c" ]] && ok="yes"; done
  [[ "$ok" == "yes" ]] || { log_err "$name must be one of: $* (got: '$val')"; return 1; }
}

# ----- Config (defaults; overridden by conf) -----
SCAN_SLEEP_SEC="$SCAN_SLEEP_SEC_DEFAULT"
ONETRY_GAP_SEC="$ONETRY_GAP_SEC_DEFAULT"
MAX_ATTEMPTS_PER_LOOP="$MAX_ATTEMPTS_PER_LOOP_DEFAULT"

ONETRY_VERIFY_MODE="$ONETRY_VERIFY_MODE_DEFAULT"
ONETRY_VERIFY_TIMEOUT_SEC="$ONETRY_VERIFY_TIMEOUT_SEC_DEFAULT"
ONETRY_VERIFY_DELAY_SEC="$ONETRY_VERIFY_DELAY_SEC_DEFAULT"

HARVEST_NODESTORE="$HARVEST_NODESTORE_DEFAULT"
SHOW_NODESTORE_PAGE_NUMBERS="$SHOW_NODESTORE_PAGE_NUMBERS_DEFAULT"
: "${SHOW_NODESTORE_PAGE_SUMMARY:=$SHOW_NODESTORE_PAGE_SUMMARY_DEFAULT}"
SHOW_NODESTORE_IPS="$SHOW_NODESTORE_IPS_DEFAULT"

  HARVEST_REMOTE_NODESTORE="$HARVEST_REMOTE_NODESTORE_DEFAULT"
  REMOTE_NODESTORE_HOST="$REMOTE_NODESTORE_HOST_DEFAULT"
  REMOTE_NODESTORE_USER="$REMOTE_NODESTORE_USER_DEFAULT"

SHOW_ROUTER_STATUS="$SHOW_ROUTER_STATUS_DEFAULT"
SHOW_ROUTER_ESTABLISHED_LIST="$SHOW_ROUTER_ESTABLISHED_LIST_DEFAULT"
SHOW_ROUTER_UNRESPONSIVE_LIST="$SHOW_ROUTER_UNRESPONSIVE_LIST_DEFAULT"

SHOW_CORE_PEERS="$SHOW_CORE_PEERS_DEFAULT"

PING_ENABLE="$PING_ENABLE_DEFAULT"
PING_TIMEOUT_SEC="$PING_TIMEOUT_SEC_DEFAULT"

RETRY_TRIED_EVERY_LOOPS="$RETRY_TRIED_EVERY_LOOPS_DEFAULT"
RECHECK_CONFIRMED_EVERY_LOOPS="$RECHECK_CONFIRMED_EVERY_LOOPS_DEFAULT"
RECHECK_CONFIRMED_MAX_PER_LOOP="$RECHECK_CONFIRMED_MAX_PER_LOOP_DEFAULT"

COMPACT_DASHBOARD="$COMPACT_DASHBOARD_DEFAULT"
COUNTDOWN_SLEEP="$COUNTDOWN_SLEEP_DEFAULT"

print_config() {
  cat <<CFG
# cjdnsharvestv2 config: $CONF_PATH
SCAN_SLEEP_SEC=$SCAN_SLEEP_SEC
ONETRY_GAP_SEC=$ONETRY_GAP_SEC
MAX_ATTEMPTS_PER_LOOP=$MAX_ATTEMPTS_PER_LOOP

ONETRY_VERIFY_MODE=$ONETRY_VERIFY_MODE
ONETRY_VERIFY_TIMEOUT_SEC=$ONETRY_VERIFY_TIMEOUT_SEC
ONETRY_VERIFY_DELAY_SEC=$ONETRY_VERIFY_DELAY_SEC

HARVEST_NODESTORE=$HARVEST_NODESTORE
SHOW_NODESTORE_PAGE_NUMBERS=$SHOW_NODESTORE_PAGE_NUMBERS
SHOW_NODESTORE_PAGE_SUMMARY=$SHOW_NODESTORE_PAGE_SUMMARY
SHOW_NODESTORE_IPS=$SHOW_NODESTORE_IPS

  # Remote NodeStore
  HARVEST_REMOTE_NODESTORE=$HARVEST_REMOTE_NODESTORE
  REMOTE_NODESTORE_HOST=$REMOTE_NODESTORE_HOST
  REMOTE_NODESTORE_USER=$REMOTE_NODESTORE_USER
SHOW_ROUTER_STATUS=$SHOW_ROUTER_STATUS
SHOW_ROUTER_ESTABLISHED_LIST=$SHOW_ROUTER_ESTABLISHED_LIST
SHOW_ROUTER_UNRESPONSIVE_LIST=$SHOW_ROUTER_UNRESPONSIVE_LIST

SHOW_CORE_PEERS=$SHOW_CORE_PEERS

PING_ENABLE=$PING_ENABLE
PING_TIMEOUT_SEC=$PING_TIMEOUT_SEC

RETRY_TRIED_EVERY_LOOPS=$RETRY_TRIED_EVERY_LOOPS
RECHECK_CONFIRMED_EVERY_LOOPS=$RECHECK_CONFIRMED_EVERY_LOOPS
COMPACT_DASHBOARD=$COMPACT_DASHBOARD
COUNTDOWN_SLEEP=$COUNTDOWN_SLEEP
CFG
}

load_conf_if_present() {
  [[ -f "$CONF_PATH" ]] || return 0
  # shellcheck disable=SC1090
  source "$CONF_PATH"

  # IMPORTANT: rebuild Bitcoin Core CLI after harvest.conf overrides BITCOIN_* vars.
  : "${BITCOIN_CLI_BIN:=${BITCOIN_CLI_BIN_DEFAULT:-bitcoin-cli}}"
  : "${BITCOIN_DATADIR:=${BITCOIN_DATADIR_DEFAULT:-$HOME/.bitcoin}}"
  : "${BITCOIN_CONF:=${BITCOIN_CONF_DEFAULT:-$BITCOIN_DATADIR/bitcoin.conf}}"
  CLI="$BITCOIN_CLI_BIN -datadir=$BITCOIN_DATADIR -conf=$BITCOIN_CONF"

  need_int_ge "SCAN_SLEEP_SEC" "$SCAN_SLEEP_SEC" 0
  need_int_ge "ONETRY_GAP_SEC" "$ONETRY_GAP_SEC" 0
  need_int_ge "MAX_ATTEMPTS_PER_LOOP" "$MAX_ATTEMPTS_PER_LOOP" 0

  need_choice "ONETRY_VERIFY_MODE" "$ONETRY_VERIFY_MODE" wait delay
  need_int_range "ONETRY_VERIFY_TIMEOUT_SEC" "$ONETRY_VERIFY_TIMEOUT_SEC" 1 120
  need_int_ge "ONETRY_VERIFY_DELAY_SEC" "$ONETRY_VERIFY_DELAY_SEC" 0

  need_yesno "HARVEST_NODESTORE" "$HARVEST_NODESTORE"
  need_yesno "SHOW_NODESTORE_PAGE_NUMBERS" "$SHOW_NODESTORE_PAGE_NUMBERS"
  need_yesno "SHOW_NODESTORE_PAGE_SUMMARY" "$SHOW_NODESTORE_PAGE_SUMMARY"
  need_yesno "SHOW_NODESTORE_IPS" "$SHOW_NODESTORE_IPS"

    # Remote NodeStore
    : "${HARVEST_REMOTE_NODESTORE:=$HARVEST_REMOTE_NODESTORE_DEFAULT}"
    : "${REMOTE_NODESTORE_HOST:=$REMOTE_NODESTORE_HOST_DEFAULT}"
    : "${REMOTE_NODESTORE_USER:=$REMOTE_NODESTORE_USER_DEFAULT}"
    need_yesno "HARVEST_REMOTE_NODESTORE" "$HARVEST_REMOTE_NODESTORE"

  need_yesno "SHOW_ROUTER_STATUS" "$SHOW_ROUTER_STATUS"
  need_yesno "SHOW_ROUTER_ESTABLISHED_LIST" "$SHOW_ROUTER_ESTABLISHED_LIST"
  need_yesno "SHOW_ROUTER_UNRESPONSIVE_LIST" "$SHOW_ROUTER_UNRESPONSIVE_LIST"

  need_yesno "SHOW_CORE_PEERS" "$SHOW_CORE_PEERS"
  need_yesno "PING_ENABLE" "$PING_ENABLE"
  need_int_range "PING_TIMEOUT_SEC" "$PING_TIMEOUT_SEC" 1 60

  need_int_ge "RETRY_TRIED_EVERY_LOOPS" "$RETRY_TRIED_EVERY_LOOPS" 0
  need_int_ge "RECHECK_CONFIRMED_EVERY_LOOPS" "$RECHECK_CONFIRMED_EVERY_LOOPS" 0
  need_int_ge "RECHECK_CONFIRMED_MAX_PER_LOOP" "$RECHECK_CONFIRMED_MAX_PER_LOOP" 0

  need_yesno "COMPACT_DASHBOARD" "$COMPACT_DASHBOARD"
  need_yesno "COUNTDOWN_SLEEP" "$COUNTDOWN_SLEEP"
: # DEBUG_LOG prompt removed
}

load_conf() {
  # LOCAL_CONF_GUARD_V3
  # Prefer harvest.local.conf when harvest.conf is absent (Smart Mode writes local).
  if [[ ! -f "$CONF_PATH" ]]; then
    LOCAL_CONF_PATH="${LOCAL_CONF_PATH:-${CONF_PATH%/*}/harvest.local.conf}"
    if [[ -f "$LOCAL_CONF_PATH" ]]; then
      CONF_PATH="$LOCAL_CONF_PATH"
    fi
  fi
  if [[ ! -f "$CONF_PATH" ]]; then
    log_err "Config file not found: $CONF_PATH"
    log_err "Run: $0 --run"
    exit 1
  fi

  load_conf_if_present

  # --- Defaults / normalization ---
  : "${ONETRY_CONFIRM_MODE:=batch}"      # batch (default) | inline
  : "${ONETRY_BATCH_SETTLE_SEC:=3}"     # seconds to wait after last onetry before post-snapshot (batch mode)

  # Frontier Expansion (optional)
  : "${FRONTIER_ENABLE_DEFAULT:=no}"
  : "${FRONTIER_EVERY_N_SCANS_DEFAULT:=5}"
  : "${FRONTIER_TIMEOUT_MS_DEFAULT:=2000}"

  # Debug forces inline confirmation (max signal)
}

dbg() { :; }
