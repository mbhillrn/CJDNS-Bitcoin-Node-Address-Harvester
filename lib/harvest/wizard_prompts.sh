# AUTOGENERATED from harvest.sh (wizard_prompts.sh)
# Part 2 - Continue from Part 1

prompt() {
  local label="$1" def="$2" ans
  read -r -p "$label ($def): " ans || true
  [[ -z "${ans:-}" ]] && ans="$def"
  printf '%s' "$ans"
}

prompt_yesno() {
  local label="$1" def="$2" ans
  while :; do
    ans="$(prompt "$label [yes/no]" "$def")"
    ans="${ans,,}"
    case "$ans" in
      y|yes) echo "yes"; return 0 ;;
      n|no)  echo "no";  return 0 ;;
      *) log_err "Enter yes or no." ;;
    esac
  done
}

prompt_int_ge() {
  local label="$1" def="$2" min="$3" ans
  while :; do
    ans="$(prompt "$label" "$def")"
    if ! is_int "$ans"; then log_err "Must be integer."; continue; fi
    if (( ans < min )); then log_err "Must be >= $min."; continue; fi
    echo "$ans"; return 0
  done
}

prompt_int_range() {
  local label="$1" def="$2" min="$3" max="$4" ans
  while :; do
    ans="$(prompt "$label" "$def")"
    if ! is_int "$ans"; then log_err "Must be integer."; continue; fi
    if (( ans < min || ans > max )); then log_err "Must be between $min and $max."; continue; fi
    echo "$ans"; return 0
  done
}

prompt_choice() {
  local label="$1" def="$2"; shift 2
  local ans
  while :; do
    ans="$(prompt "$label" "$def")"
    for c in "$@"; do
      [[ "$ans" == "$c" ]] && { echo "$ans"; return 0; }
    done
    log_err "Must be one of: $*"
  done
}

# PROMPT_IPV4_CSV_V2
trim_ws() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

is_ipv4() {
  local ip="$1" IFS=.
  local -a o
  [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]] || return 1
  read -r -a o <<<"$ip"
  [[ ${#o[@]} -eq 4 ]] || return 1
  for x in "${o[@]}"; do
    [[ "$x" =~ ^[0-9]+$ ]] || return 1
    (( x >= 0 && x <= 255 )) || return 1
  done
  return 0
}

prompt_ipv4_csv_required() {
  local label="$1" def="$2" ans token
  while :; do
    ans="$(prompt "$label" "$def")"
    ans="$(trim_ws "$ans")"
    ans="$(printf '%s' "$ans" | tr -d '[:space:]')"
    if [[ -z "$ans" ]]; then
      log_err "Must enter one or more IPv4 addresses (comma-separated)."
      continue
    fi
    IFS=',' read -r -a parts <<<"$ans"
    for token in "${parts[@]}"; do
      if [[ -z "$token" ]] || ! is_ipv4 "$token"; then
        log_err "Invalid IPv4 in list: '$token'  (expected like 192.168.4.102,192.168.4.110)"
        ans=""
        break
      fi
    done
    [[ -n "$ans" ]] && { printf '%s' "$ans"; return 0; }
  done
}

prompt_username_required() {
  local label="$1" def="$2" ans
  while :; do
    ans="$(prompt "$label" "$def")"
    ans="$(trim_ws "$ans")"
    if [[ -z "$ans" ]]; then
      log_err "Must enter a username (non-empty)."
      continue
    fi
    # forbid whitespace or commas (common fat-finger)
    if [[ "$ans" =~ [[:space:],] ]]; then
      log_err "Username must not contain spaces or commas."
      continue
    fi
    printf '%s' "$ans"
    return 0
  done
}


# LOCAL_CONF_PATH_V1
# Local layer for per-machine choices (not committed). Defaults next to CONF_PATH.
: "${CONF_PATH:=./harvest.conf}"
LOCAL_CONF_PATH="${LOCAL_CONF_PATH:-${CONF_PATH%harvest.conf}harvest.local.conf}"


write_conf_atomic() {
  local tmpc="/tmp/harvest.conf.$$"
  umask 077
  cat >"$tmpc" <<CFG
# cjdnsharvestv2 config (generated by wizard)

# Detected/selected runtime settings (persisted)
BITCOIN_CLI_BIN=$BITCOIN_CLI_BIN
BITCOIN_DATADIR=$BITCOIN_DATADIR
BITCOIN_CONF=$BITCOIN_CONF
CJDNS_ADMIN_ADDR=$CJDNS_ADMIN_ADDR
CJDNS_ADMIN_PORT=$CJDNS_ADMIN_PORT

SCAN_SLEEP_SEC=$SCAN_SLEEP_SEC
ONETRY_GAP_SEC=$ONETRY_GAP_SEC
MAX_ATTEMPTS_PER_LOOP=$MAX_ATTEMPTS_PER_LOOP

# Onetry confirmation mode
ONETRY_CONFIRM_MODE=$ONETRY_CONFIRM_MODE
ONETRY_BATCH_SETTLE_SEC=$ONETRY_BATCH_SETTLE_SEC

# Inline verify (only used when ONETRY_CONFIRM_MODE=inline)
ONETRY_VERIFY_MODE=$ONETRY_VERIFY_MODE
ONETRY_VERIFY_TIMEOUT_SEC=$ONETRY_VERIFY_TIMEOUT_SEC
ONETRY_VERIFY_DELAY_SEC=$ONETRY_VERIFY_DELAY_SEC

# NodeStore harvesting
HARVEST_NODESTORE=$HARVEST_NODESTORE
SHOW_NODESTORE_PAGE_NUMBERS=$SHOW_NODESTORE_PAGE_NUMBERS
SHOW_NODESTORE_PAGE_SUMMARY=$SHOW_NODESTORE_PAGE_SUMMARY

  # Remote NodeStore harvesting
  HARVEST_REMOTE_NODESTORE=$HARVEST_REMOTE_NODESTORE
  REMOTE_NODESTORE_HOST=$REMOTE_NODESTORE_HOST
  REMOTE_NODESTORE_USER=$REMOTE_NODESTORE_USER

# Display blocks
SHOW_ROUTER_STATUS=$SHOW_ROUTER_STATUS
SHOW_ROUTER_ESTABLISHED_LIST=$SHOW_ROUTER_ESTABLISHED_LIST
SHOW_ROUTER_UNRESPONSIVE_LIST=$SHOW_ROUTER_UNRESPONSIVE_LIST
SHOW_CORE_PEERS=$SHOW_CORE_PEERS

# Ping (informational only)
PING_ENABLE=$PING_ENABLE
PING_TIMEOUT_SEC=$PING_TIMEOUT_SEC

# Retry policies
RETRY_TRIED_EVERY_LOOPS=$RETRY_TRIED_EVERY_LOOPS
RECHECK_CONFIRMED_EVERY_LOOPS=$RECHECK_CONFIRMED_EVERY_LOOPS
RECHECK_CONFIRMED_MAX_PER_LOOP=$RECHECK_CONFIRMED_MAX_PER_LOOP
# UI
COMPACT_DASHBOARD=$COMPACT_DASHBOARD
COUNTDOWN_SLEEP=$COUNTDOWN_SLEEP

# Logging
CFG
  mkdir -p "$BASE_DIR"
  # SMART_WRITE_LOCAL_V2
  # In Smart Mode, write to LOCAL_CONF_PATH so the repo-visible harvest.conf stays clean.
  out="$CONF_PATH"
  if [[ "${SMART_MODE:-no}" == "yes" ]] && [[ -n "${LOCAL_CONF_PATH:-}" ]]; then
    out="$LOCAL_CONF_PATH"
  fi
  mv -f "$tmpc" "$out"

}

apply_smart_defaults_runtime() {
  # Runtime-only: do NOT write these into harvest.conf (unless you explicitly choose to).
  # Smart Mode is meant to be stable even if regular-mode wizard keeps changing saved defaults.

  # Wizard-esque knobs (your requested smart defaults)
  QUICK_SAVE="no"
  COMPACT_DASHBOARD="no"

  SHOW_ROUTER_STATUS="yes"
  SHOW_ROUTER_ESTABLISHED_LIST="yes"
  SHOW_ROUTER_UNRESPONSIVE_LIST="yes"
  SHOW_CORE_PEERS="yes"
  SCAN_SLEEP_SEC="${SMART_SCAN_SLEEP_SEC:-6}"
  COUNTDOWN_SLEEP="yes"

  HARVEST_NODESTORE="yes"
  SHOW_NODESTORE_PAGE_NUMBERS="yes"
  SHOW_NODESTORE_PAGE_SUMMARY="yes"
  SHOW_NODESTORE_IPS="yes"

    # Remote NodeStore in Smart Mode:
    # Wizard(run) stores answers in SMART_* env vars. If unset, default OFF.
    HARVEST_REMOTE_NODESTORE="${SMART_HARVEST_REMOTE_NODESTORE:-no}"
    REMOTE_NODESTORE_HOST="${SMART_REMOTE_NODESTORE_HOST:-}"
    REMOTE_NODESTORE_USER="${SMART_REMOTE_NODESTORE_USER:-}"

  ONETRY_GAP_SEC="0"

  ONETRY_CONFIRM_MODE="batch"
  ONETRY_BATCH_SETTLE_SEC="5"

  PING_ENABLE="yes"
  PING_TIMEOUT_SEC="3"

  MAX_ATTEMPTS_PER_LOOP="0"

  # IMPORTANT: Smart Mode uses its own master scheduler (below), so disable classic retry knob.
  RETRY_TRIED_EVERY_LOOPS="0"

  # Still recheck confirmed periodically (your ask)
  RECHECK_CONFIRMED_EVERY_LOOPS="5"
  RECHECK_CONFIRMED_MAX_PER_LOOP="0"
}

smart_db_init_schema() {
  # Add smart tables (idempotent)
  sqlite3 "$DB_PATH" <<'SQL' >/dev/null
CREATE TABLE IF NOT EXISTS smart_master_state (
  host TEXT PRIMARY KEY,
  stage INTEGER NOT NULL DEFAULT 0,          -- 0,1,2 (cooldowns 5,10,50)
  fails_in_stage INTEGER NOT NULL DEFAULT 0, -- counts up to 2 then triggers cooldown + stage increment
  cooldown_runs INTEGER NOT NULL DEFAULT 0   -- how many loops remaining until eligible
);
SQL
}

smart_reset_state_if_first_loop() {
  # Reset smart cooldown bookkeeping when you ENTER smart mode (start of this run session).
  # We key this off a runtime SMART_SESSION_ID stored in meta.
  # New session => wipe smart state + reset cursor.
  local loop_num="${1:-0}"

  [[ "${SMART_MODE:-no}" == "yes" ]] || return 0
  [[ -n "${SMART_SESSION_ID:-}" ]] || return 0

  local prior
  prior="$(sqlite3 "$DB_PATH" "SELECT value FROM meta WHERE key='smart_session_id' LIMIT 1;" 2>/dev/null || true)"

  if [[ "$prior" != "$SMART_SESSION_ID" ]]; then
    sqlite3 "$DB_PATH" <<SQL >/dev/null
DELETE FROM smart_master_state;
INSERT INTO meta(key,value) VALUES('smart_master_cursor','0')
ON CONFLICT(key) DO UPDATE SET value=excluded.value;
INSERT INTO meta(key,value) VALUES('smart_session_id','$SMART_SESSION_ID')
ON CONFLICT(key) DO UPDATE SET value=excluded.value;
SQL
    echo "Smart Mode: reset smart state (new session_id)."
  fi
}

smart_tick_cooldowns() {
  # Decrement cooldown counters once per loop (run-based cooldowns).
  sqlite3 "$DB_PATH" <<'SQL' >/dev/null
UPDATE smart_master_state
SET cooldown_runs = CASE WHEN cooldown_runs > 0 THEN cooldown_runs - 1 ELSE 0 END;
SQL
}
smart_get_cursor() {
  # MUST emit exactly one integer token (no extra newlines/spaces).
  local cur
  cur="$(db_meta_get smart_master_cursor 0 2>/dev/null || echo 0)"
  cur="$(num_sanitize "$cur")"
  printf '%s' "$cur"
}

smart_set_cursor() {
  local cur="${1:-0}"
  [[ "$cur" =~ ^[0-9]+$ ]] || cur=0
  sqlite3 "$DB_PATH" "INSERT INTO meta(key,value) VALUES('smart_master_cursor','$cur') ON CONFLICT(key) DO UPDATE SET value=excluded.value;" >/dev/null 2>&1 || true
}

smart_pick_master_10() {
  # Picks up to 10 MASTER hosts in deterministic order (first_seen_ts ASC, host ASC),
  # walking forward from a persistent cursor. Skips:
  # - confirmed
  # - already connected pre-snapshot
  # - in cooldown
  #
  # Args: connected_now_file out_file
  local connected_now_file="${1:?connected_now_file}"
  local out_file="${2:?out_file}"
  : >"$out_file"

  local cur total
  cur="$(smart_get_cursor)"
  total="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM master;" 2>/dev/null || echo 0)"
  [[ "$total" =~ ^[0-9]+$ ]] || total=0
  if (( total <= 0 )); then
    smart_set_cursor 0
    return 0
  fi

  local picked=0 advanced=0 idx="$cur"

  # Hard cap to avoid infinite loops if everything is ineligible
  local steps=0 max_steps=$((total + 50))

  while (( picked < 10 )) && (( steps < max_steps )); do
    steps=$((steps+1))

    # Wrap cursor
    if (( idx >= total )); then
      idx=0
    fi

    # Get the idx-th row in master ordering
    # NOTE: OFFSET is 0-based.
    host="$(sqlite3 -noheader -batch "$DB_PATH" "
      SELECT host FROM master
      ORDER BY first_seen_ts ASC, host ASC
      LIMIT 1 OFFSET $idx;
    " 2>/dev/null || true)"
    idx=$((idx+1))
    advanced=$((advanced+1))

    [[ -n "${host:-}" ]] || continue

    # Skip if connected right now
    if grep -qxF "$host" "$connected_now_file" 2>/dev/null; then
      continue
    fi

    # Skip if confirmed
    if [[ "$(sqlite3 "$DB_PATH" "SELECT 1 FROM confirmed WHERE host='$host' LIMIT 1;" 2>/dev/null || true)" == "1" ]]; then
      continue
    fi

    # Skip if in cooldown
    cd="$(sqlite3 "$DB_PATH" "SELECT cooldown_runs FROM smart_master_state WHERE host='$host' LIMIT 1;" 2>/dev/null || true)"
    [[ "$cd" =~ ^[0-9]+$ ]] || cd=0
    if (( cd > 0 )); then
      continue
    fi

    printf '%s
' "$host" >>"$out_file"
    picked=$((picked+1))
  done

  # Persist new cursor position (idx is where we stopped)
  smart_set_cursor "$idx"
}

smart_update_results_from_batch() {
  # Args:
  #   $1 attempted_file (one host per line)
  #   $2 new_hosts_blob (newline-separated hosts that became connected in the batch diff)
  local attempted_file="${1:?attempted_file}"
  local new_hosts="${2:-}"

  [[ -s "$attempted_file" ]] || return 0

  while IFS= read -r host; do
    [[ -n "$host" ]] || continue

    # success if host is in new_hosts
    if printf '%s\n' "$new_hosts" | grep -qxF "$host"; then
      sqlite3 "$DB_PATH" <<SQL >/dev/null
.parameter init
.parameter set @host '$host'
INSERT INTO smart_master_state(host,stage,fails_in_stage,cooldown_runs)
VALUES(@host,0,0,0)
ON CONFLICT(host) DO UPDATE SET stage=0, fails_in_stage=0, cooldown_runs=0;
SQL
      continue
    fi

    # failure path
    local stage fails
    stage="$(sqlite3 "$DB_PATH" "SELECT stage FROM smart_master_state WHERE host='$host' LIMIT 1;" 2>/dev/null || true)"
    fails="$(sqlite3 "$DB_PATH" "SELECT fails_in_stage FROM smart_master_state WHERE host='$host' LIMIT 1;" 2>/dev/null || true)"
    [[ "$stage" =~ ^[0-9]+$ ]] || stage=0
    [[ "$fails" =~ ^[0-9]+$ ]] || fails=0

    fails=$((fails+1))

    if (( fails >= 2 )); then
      local cooldown new_stage
      # stage 0 => cooldown 5, stage 1 => cooldown 10, stage 2+ => cooldown 50
      if (( stage == 0 )); then
        cooldown=5
      elif (( stage == 1 )); then
        cooldown=10
      else
        cooldown=50
      fi

      new_stage=$stage
      if (( new_stage < 2 )); then
        new_stage=$((new_stage+1))
      fi

      sqlite3 "$DB_PATH" <<SQL >/dev/null
.parameter init
.parameter set @host '$host'
INSERT INTO smart_master_state(host,stage,fails_in_stage,cooldown_runs)
VALUES(@host,$new_stage,0,$cooldown)
ON CONFLICT(host) DO UPDATE SET stage=$new_stage, fails_in_stage=0, cooldown_runs=$cooldown;
SQL
    else
      sqlite3 "$DB_PATH" <<SQL >/dev/null
.parameter init
.parameter set @host '$host'
INSERT INTO smart_master_state(host,stage,fails_in_stage,cooldown_runs)
VALUES(@host,$stage,$fails,0)
ON CONFLICT(host) DO UPDATE SET stage=$stage, fails_in_stage=$fails;
SQL
    fi
  done <"$attempted_file"
}

setup() {
  # ADMIN_CONFIRM_CONDITIONAL_V1
  CJDNS_ADMIN_DETECTED="no"

  # v5: minimal interactive setup (NO wizard)
  # Writes harvest.conf so Enter keeps last selections.
  log_info "Setup. Writes: $CONF_PATH"


  # WIZARD_INIT_DEFAULTS_V1
  # Ensure variables referenced by write_conf_atomic() are never unbound.
  : "${ONETRY_CONFIRM_MODE:=batch}"
  : "${ONETRY_BATCH_SETTLE_SEC:=5}"
  : "${ONETRY_VERIFY_MODE:=wait}"
  : "${ONETRY_VERIFY_TIMEOUT_SEC:=5}"
  : "${ONETRY_VERIFY_DELAY_SEC:=0}"

  : "${RECHECK_CONFIRMED_MAX_PER_LOOP:=0}"

  # ----------------------------------------------------------------------
  # Early environment detection (portable install):
  #   - Detect/confirm Bitcoin Core bitcoin-cli/datadir/conf
  #   - Detect/confirm cjdns admin addr/port
  # These become variables used by the rest of the run and are persisted
  # into harvest.conf by the config writer.
  # ----------------------------------------------------------------------
  if declare -F cjdh_build_bitcoin_cli >/dev/null 2>&1; then
    # Sets: BITCOIN_CLI_BIN, BITCOIN_DATADIR, BITCOIN_CONF
    cjdh_build_bitcoin_cli >/dev/null || true
  fi

      if declare -F cjdh_detect_cjdns_admin >/dev/null 2>&1; then
      # Output "addr|port"
      det="$(cjdh_detect_cjdns_admin 2>/dev/null || true)"
      if [[ "$det" == *"|"* ]]; then
        CJDNS_ADMIN_ADDR="${det%%|*}"
        CJDNS_ADMIN_PORT="${det#*|}"
        CJDNS_ADMIN_DETECTED="yes"
      fi
    fi

    # If admin was not auto-detected, ask for it now (no extra yes/no gate).
    if [[ "${CJDNS_ADMIN_DETECTED:-no}" != "yes" ]]; then
      echo
      echo "[WARN] cjdns admin was not auto-detected. Please enter it."
      CJDNS_ADMIN_ADDR="$(cjdh_prompt_path "cjdns admin addr" "${CJDNS_ADMIN_ADDR:-127.0.0.1}")"
      CJDNS_ADMIN_PORT="$(cjdh_prompt_path "cjdns admin port" "${CJDNS_ADMIN_PORT:-11234}")"
    fi

  echo "Detected settings:"
  echo "  bitcoin-cli : ${BITCOIN_CLI_BIN:-<unset>}"
  echo "  datadir     : ${BITCOIN_DATADIR:-<unset>}"
  echo "  conf        : ${BITCOIN_CONF:-<unset>}"
  # ADMIN_DETECT_LABEL_V1
  admin_src="default"
  if [[ "${CJDNS_ADMIN_DETECTED:-no}" == "yes" ]]; then admin_src="auto-detected"; fi
  echo "  cjdns admin : ${CJDNS_ADMIN_ADDR:-127.0.0.1}:${CJDNS_ADMIN_PORT:-11234} (${admin_src})"

  echo
  # Only prompt to override cjdns admin when it was NOT auto-detected.
  # Set WIZARD_CONFIRM_ADMIN_ALWAYS=yes to force prompting every time.
  if [[ "${WIZARD_CONFIRM_ADMIN_ALWAYS:-no}" == "yes" || "${CJDNS_ADMIN_DETECTED:-no}" != "yes" ]]; then

  # BITCOIN_CONFIRM_CONDITIONAL_V2
  # Only prompt if any required Bitcoin Core setting is missing/unusable.
  missing="no"

  # If bitcoin-cli isn't runnable, treat as missing.
  if [[ -z "${BITCOIN_CLI_BIN:-}" ]] || ! command -v "${BITCOIN_CLI_BIN%% *}" >/dev/null 2>&1; then
    missing="yes"
  fi

  # If datadir missing or doesn't exist, missing.
  if [[ -z "${BITCOIN_DATADIR:-}" ]] || [[ ! -d "$BITCOIN_DATADIR" ]]; then
    missing="yes"
  fi

  # If conf missing or doesn't exist, missing.
  if [[ -z "${BITCOIN_CONF:-}" ]] || [[ ! -f "$BITCOIN_CONF" ]]; then
    missing="yes"
  fi

  if [[ "$missing" == "yes" ]]; then
    echo
    echo "[WARN] Bitcoin Core settings were not fully auto-detected. Please enter the missing pieces."
    if [[ -z "${BITCOIN_CLI_BIN:-}" ]] || ! command -v "${BITCOIN_CLI_BIN%% *}" >/dev/null 2>&1; then
      BITCOIN_CLI_BIN="$(cjdh_prompt_path "bitcoin-cli command" "${BITCOIN_CLI_BIN:-bitcoin-cli}")"
    fi
    if [[ -z "${BITCOIN_DATADIR:-}" ]] || [[ ! -d "$BITCOIN_DATADIR" ]]; then
      BITCOIN_DATADIR="$(cjdh_prompt_path "Bitcoin datadir" "${BITCOIN_DATADIR:-/srv/bitcoin}")"
    fi
    if [[ -z "${BITCOIN_CONF:-}" ]] || [[ ! -f "$BITCOIN_CONF" ]]; then
      BITCOIN_CONF="$(cjdh_prompt_path "bitcoin.conf path" "${BITCOIN_CONF:-/srv/bitcoin/bitcoin.conf}")"
    fi
  fi
  fi

  if declare -F cjdh_verify_cjdns_admin >/dev/null 2>&1; then
    cjdh_verify_cjdns_admin "${CJDNS_ADMIN_ADDR:-127.0.0.1}" "${CJDNS_ADMIN_PORT:-11234}" \
      || cjdh_die "cjdns admin not reachable at ${CJDNS_ADMIN_ADDR}:${CJDNS_ADMIN_PORT}"
  fi
  # Final fallback defaults (do not leave unset)
  : "${BITCOIN_CLI_BIN:=${BITCOIN_CLI_BIN:-bitcoin-cli}}"
  : "${BITCOIN_DATADIR:=${BITCOIN_DATADIR:-$HOME/.bitcoin}}"
  : "${BITCOIN_CONF:=${BITCOIN_CONF:-$BITCOIN_DATADIR/bitcoin.conf}}"
  : "${CJDNS_ADMIN_ADDR:=${CJDNS_ADMIN_ADDR:-127.0.0.1}}"
  : "${CJDNS_ADMIN_PORT:=${CJDNS_ADMIN_PORT:-11234}}"


  echo

  # Load existing config first so defaults come from what you last picked.
  [[ -f "$CONF_PATH" ]] && load_conf >/dev/null 2>&1 || true

  # Forced defaults: always batch, unlimited attempts, show everything
  COMPACT_DASHBOARD="no"
  SHOW_ROUTER_STATUS="yes"
  SHOW_ROUTER_ESTABLISHED_LIST="yes"
  SHOW_ROUTER_UNRESPONSIVE_LIST="yes"
  SHOW_CORE_PEERS="yes"
  COUNTDOWN_SLEEP="yes"
  HARVEST_NODESTORE="yes"
  SHOW_NODESTORE_PAGE_NUMBERS="yes"
  SHOW_NODESTORE_PAGE_SUMMARY="yes"
  SHOW_NODESTORE_IPS="yes"
  RECHECK_CONFIRMED_MAX_PER_LOOP="0"
  MAX_ATTEMPTS_PER_LOOP="0"
  ONETRY_CONFIRM_MODE="batch"

  # Primary selector
    # SOURCE_LOCAL_CONF_V2
    # Load saved settings so defaults in prompts reflect your last entries.
    [[ -f "$CONF_PATH" ]] && source "$CONF_PATH" || true
    [[ -n "${LOCAL_CONF_PATH:-}" && -f "$LOCAL_CONF_PATH" ]] && source "$LOCAL_CONF_PATH" || true

    # SMART_DEFAULTS_FROM_REMOTE_V1
    # If Smart-mode vars are empty but normal-mode vars exist, reuse them as defaults.
    : "${SMART_REMOTE_NODESTORE_HOST:=${REMOTE_NODESTORE_HOST:-}}"
    : "${SMART_REMOTE_NODESTORE_USER:=${REMOTE_NODESTORE_USER:-}}"

  SMART_MODE="$(prompt_yesno "Run in Smart Mode?!" "${SMART_MODE:-yes}")"

  if [[ "$SMART_MODE" == "yes" ]]; then
    SMART_SCAN_SLEEP_SEC="$(prompt_int_ge "Seconds between SMART scans" "${SMART_SCAN_SLEEP_SEC:-${SCAN_SLEEP_SEC:-$SCAN_SLEEP_SEC_DEFAULT}}" 0)"
    FRONTIER_ENABLE="$(prompt_yesno "Enable Frontier Expansion (PeerInfo/getPeers)" "${FRONTIER_ENABLE:-yes}")"
    if [[ "$FRONTIER_ENABLE" == "yes" ]]; then
      FRONTIER_EVERY_N_SCANS="$(prompt_int_ge "Run Frontier every N scans (0=off)" "${FRONTIER_EVERY_N_SCANS:-5}" 0)"
    else
      FRONTIER_EVERY_N_SCANS="0"
    fi

    SMART_HARVEST_REMOTE_NODESTORE="$(prompt_yesno "Harvest remote nodestore (SSH to another cjdns node)" "${SMART_HARVEST_REMOTE_NODESTORE:-no}")"
    if [[ "$SMART_HARVEST_REMOTE_NODESTORE" == "yes" ]]; then
      SMART_REMOTE_NODESTORE_HOST="$(prompt_ipv4_csv_required "Remote NodeStore host/IP(s) (comma-separated)" "${SMART_REMOTE_NODESTORE_HOST:-}")"
      SMART_REMOTE_NODESTORE_USER="$(prompt_username_required "Remote NodeStore SSH user (same for all)" "${SMART_REMOTE_NODESTORE_USER:-}")"
    fi
      # SMART_COPY_TO_REMOTE_V2
      # Persist Smart-mode remote nodestore choices using the normal REMOTE_* keys
      # so they load as defaults next run (and so the writer saves them).
      HARVEST_REMOTE_NODESTORE="$SMART_HARVEST_REMOTE_NODESTORE"
      if [[ "$SMART_HARVEST_REMOTE_NODESTORE" == "yes" ]]; then
        REMOTE_NODESTORE_HOST="$SMART_REMOTE_NODESTORE_HOST"
        REMOTE_NODESTORE_USER="$SMART_REMOTE_NODESTORE_USER"
      fi


    write_conf_atomic

  # LOG_WROTE_OUT_V1
  log_info "Wrote config: ${out:-$CONF_PATH}"

    return 0
  fi

  # Normal Mode minimal prompts
  SCAN_SLEEP_SEC="$(prompt_int_ge "Seconds between scans" "${SCAN_SLEEP_SEC:-$SCAN_SLEEP_SEC_DEFAULT}" 0)"

  FRONTIER_ENABLE="$(prompt_yesno "Enable Frontier Expansion (PeerInfo/getPeers)" "${FRONTIER_ENABLE:-no}")"
  if [[ "$FRONTIER_ENABLE" == "yes" ]]; then
    FRONTIER_EVERY_N_SCANS="$(prompt_int_ge "Run Frontier every N scans (0=off)" "${FRONTIER_EVERY_N_SCANS:-5}" 0)"
  else
    FRONTIER_EVERY_N_SCANS="0"
  fi

  HARVEST_REMOTE_NODESTORE="$(prompt_yesno "Harvest remote nodestore (SSH to another cjdns node)" "${HARVEST_REMOTE_NODESTORE:-no}")"
  if [[ "$HARVEST_REMOTE_NODESTORE" == "yes" ]]; then
    REMOTE_NODESTORE_HOST="$(prompt_ipv4_csv_required "Remote NodeStore host/IP(s) (comma-separated)" "${REMOTE_NODESTORE_HOST:-}")"
    REMOTE_NODESTORE_USER="$(prompt_username_required "Remote NodeStore SSH user (same for all)" "${REMOTE_NODESTORE_USER:-}")"
  fi

  RETRY_TRIED_EVERY_LOOPS="$(prompt_int_ge "Retry master list every N scans (0=off)" "${RETRY_TRIED_EVERY_LOOPS:-$RETRY_TRIED_EVERY_LOOPS_DEFAULT}" 0)"
  RECHECK_CONFIRMED_EVERY_LOOPS="$(prompt_int_ge "Recheck confirmed list every N scans (0=off)" "${RECHECK_CONFIRMED_EVERY_LOOPS:-$RECHECK_CONFIRMED_EVERY_LOOPS_DEFAULT}" 0)"

  ONETRY_GAP_SEC="$(prompt_int_ge "Seconds between onetry attempts" "${ONETRY_GAP_SEC:-$ONETRY_GAP_SEC_DEFAULT}" 0)"
  ONETRY_BATCH_SETTLE_SEC="$(prompt_int_range "Grace period after onetry batch (0-30)" "${ONETRY_BATCH_SETTLE_SEC:-3}" 0 30)"

  PING_ENABLE="$(prompt_yesno "Enable informational ping (does not gate onetry)" "${PING_ENABLE:-$PING_ENABLE_DEFAULT}")"
  if [[ "${PING_ENABLE:-yes}" =~ ^(no|n|0|false)$ ]]; then
    PING_TIMEOUT_SEC=1
  else
    PING_TIMEOUT_SEC="$(prompt_int_range "Ping timeout seconds" "${PING_TIMEOUT_SEC:-$PING_TIMEOUT_SEC_DEFAULT}" 1 60)"
  fi

  write_conf_atomic
  log_info "Wrote config: ${out:-$CONF_PATH}"

}

db_init() {
  mkdir -p "$BASE_DIR"
  [[ -f "$DB_PATH" ]] || : >"$DB_PATH"

  # Discard stdout so PRAGMA journal_mode doesn't print "wal"
  run_cmd_capture "sqlite_init" sqlite3 "$DB_PATH" <<'SQL' >/dev/null
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;

CREATE TABLE IF NOT EXISTS nodes (
  ip TEXT PRIMARY KEY,
  state TEXT NOT NULL DEFAULT 'NEW',
  first_seen_ts INTEGER,
  last_seen_ts INTEGER,
  attempts INTEGER NOT NULL DEFAULT 0,
  last_attempt_ts INTEGER,
  consec_fail INTEGER NOT NULL DEFAULT 0,
  next_eligible_loop INTEGER NOT NULL DEFAULT 0,
  last_ping_ms INTEGER,
  last_result TEXT,
  last_core_dir TEXT,
  last_core_seen_ts INTEGER,
  source_mask INTEGER NOT NULL DEFAULT 0
);

CREATE TABLE IF NOT EXISTS paths (
  ip TEXT PRIMARY KEY,
  path TEXT NOT NULL,
  last_seen_ts INTEGER
);

CREATE TABLE IF NOT EXISTS meta (
  key TEXT PRIMARY KEY,
  value TEXT
);
SQL
  dbg "DB initialized at $DB_PATH"
}

# ----- Address helpers (display + matching) -----
# Only strip :port when IPv6 is bracketed, e.g. [fc..]:8333
cjdns_host_from_maybe_bracketed() {
  local a="${1:-}"
  # Only strip :port when IPv6 is bracketed: [fc..]:8333
  if [[ "$a" =~ ^\[([0-9A-Fa-f:]+)\]:[0-9]{1,5}$ ]]; then
    printf '%s\n' "${BASH_REMATCH[1],,}"
  else
    # Bare IPv6 (including 8th-hextet digits like :1858) is treated as address, not port.
    printf '%s\n' "${a,,}"
  fi
}

ping_host() {
  # Informational only: return 0 if ping replies, else nonzero.
  # Args: host [timeout_seconds]
  local host="${1:-}"
  local timeout="${2:-1}"

  [[ -n "$host" ]] || return 2
  [[ "$timeout" =~ ^[0-9]+$ ]] || timeout=1

  # Prefer ping6 if present; otherwise use ping -6
  if command -v ping6 >/dev/null 2>&1; then
    ping6 -c 1 -W "$timeout" "$host" >/dev/null 2>&1
    return $?
  fi

  if command -v ping >/dev/null 2>&1; then
    ping -6 -c 1 -W "$timeout" "$host" >/dev/null 2>&1
    return $?
  fi

  # No ping binary available
  return 2
}
