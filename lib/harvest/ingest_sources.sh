# AUTOGENERATED from harvest.sh (ingest_sources.sh)
# Part 3 - Continue from Part 2

# ----- Ingest (Phase 3) -----
ingest_core_peers_to_db() {
  local peers raw host
  peers="$(run_cmd_capture_json "getpeerinfo" bash -lc "$CLI getpeerinfo")"
  if ! cjdh_json_must_start "getpeerinfo" "$peers"; then
    log_warn "getpeerinfo not JSON; skipping core peer ingest this loop."
    return 0
  fi

  echo "$peers" | jq -r '.[] | select(.network=="cjdns") | .addr' | while IFS= read -r raw; do
    host="$(cjdns_host_from_maybe_bracketed "$raw")"
    db_upsert_master "$host" "core"
    db_upsert_confirmed "$host"
  done
}

ingest_addrman_cjdns_to_db() {
  local j
  j="$(run_cmd_capture "addrman_cjdns" bash -lc "$CLI getnodeaddresses 0 cjdns")" || return 0
  echo "$j" | jq -r '.[]? | .address' | while IFS= read -r host; do
    [[ -n "$host" && "$host" != "null" ]] || continue
    db_upsert_master "$host" "addrman"
  done
}

ingest_nodestore_to_db() {
  [[ "$HARVEST_NODESTORE" == "yes" ]] || return 0

    print_section "NodeStore Harvest"

  echo
  echo "NodeStore harvest"

  : "${PHASE4_NEW_HOSTS_FILE:=}"
  if [[ -n "${PHASE4_NEW_HOSTS_FILE:-}" ]]; then
    : >"$PHASE4_NEW_HOSTS_FILE"
  fi

    local page=0 more=1 json
    # Optional verbosity knob (default OFF)
    : "${SHOW_NODESTORE_PAGE_SUMMARY:=no}"
      : "${SHOW_NODESTORE_IPS:=no}"

    local pages=0 total_seen=0 total_new=0 total_existing=0

    while :; do
        if [[ "$SHOW_NODESTORE_PAGE_NUMBERS" == "yes" ]]; then
          printf "${C_DIM}  Fetching page %s...${C_RESET}" "$page"
        fi

      local tmpjson="$TMPDIR/harvest.nodestore.$$.p${page}.json"

      # Capture page JSON to file (avoid storing large JSON blobs in a bash variable)
      if ! run_cmd_capture "nodestore_p$page" cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec NodeStore_dumpTable --page="$page" >"$tmpjson"; then
          [[ "$SHOW_NODESTORE_PAGE_NUMBERS" == "yes" ]] && echo " ${C_BGREEN}done!${C_RESET}"
          [[ "$SHOW_NODESTORE_PAGE_NUMBERS" == "yes" ]] && echo " ${C_BGREEN}done!${C_RESET}"
        rm -f "$tmpjson"
        break
      fi

      # Stop if this page has zero addresses (your rule) OR if .more != 1
      local rt_len
      rt_len="$(jq '.routingTable | length' "$tmpjson" 2>/dev/null || echo 0)"
      if [[ "$rt_len" =~ ^[0-9]+$ ]] && (( rt_len == 0 )); then
        rm -f "$tmpjson"
        break
      fi

      local page_seen=0 page_new=0 page_existing=0

      local ipsfile="$TMPDIR/harvest.nodestore.$$.p${page}.ips"
      jq -r '.routingTable[]? | .ip // empty' "$tmpjson" >"$ipsfile" 2>/dev/null || : >"$ipsfile"

      # Optional: show harvested addresses per page (new vs already-in-master)
      local page_new_file page_old_file
      page_new_file="$TMPDIR/harvest.nodestore.$$.p${page}.new"
      page_old_file="$TMPDIR/harvest.nodestore.$$.p${page}.old"
      if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
        : >"$page_new_file"
        : >"$page_old_file"
      fi

      while IFS= read -r ip; do
        host="$(cjdns_host_from_maybe_bracketed "$ip")"
        [[ -n "$host" ]] || continue
        page_seen=$((page_seen+1))

        now="$(date +%s)"
        inserted="$(sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO master(host, first_seen_ts, last_seen_ts, source_flags) VALUES('$host',$now,$now,'nodestore'); SELECT changes();")"

        if [[ "${inserted:-0}" == "1" ]]; then
          page_new=$((page_new+1))
          if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
            printf '%s
' "$host" >>"$page_new_file"
          fi
          if [[ -n "${PHASE4_NEW_HOSTS_FILE:-}" ]]; then
            printf '%s\n' "$host" >>"$PHASE4_NEW_HOSTS_FILE"
          fi
        else
          page_existing=$((page_existing+1))
          if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
            printf '%s
' "$host" >>"$page_old_file"
          fi
          db_upsert_master "$host" "nodestore"
        fi
      done <"$ipsfile"
      rm -f "$ipsfile"

        # Accumulate totals for final summary
        pages=$((pages+1))
        total_seen=$((total_seen+page_seen))
        total_new=$((total_new+page_new))
        total_existing=$((total_existing+page_existing))

      # Per-page visibility (debug): show what this page contributed
      if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then

          printf "      ${C_LIGHT_GRAY}Already harvested:${C_RESET}\n"
        if [[ ! -s "$page_old_file" ]]; then
          echo "        (none)"
        else
            while IFS= read -r addr; do
              printf "        ${C_LIGHT_GRAY}• %s${C_RESET}\n" "$addr"
            done <"$page_old_file"
        fi

        echo
          printf "      ${C_DULL_RED}Unharvested:${C_RESET}\n"
        if [[ ! -s "$page_new_file" ]]; then
          echo "        (none)"
        else
          sed 's/$/ (FOUND NEW!!)/' "$page_new_file" | sed 's/^/        • /'
        fi
          if (( page_new > 0 )); then
            printf "    ${C_LIGHT_RED}summary: rt_len=%s  seen=%s  new=${C_BRIGHT_RED}%s${C_RESET}${C_LIGHT_RED}  existing=%s${C_RESET}\n" "$rt_len" "$page_seen" "$page_new" "$page_existing"
          else
            printf "    ${C_LIGHT_RED}summary: rt_len=%s  seen=%s  new=%s  existing=%s${C_RESET}\n" "$rt_len" "$page_seen" "$page_new" "$page_existing"
          fi
      fi

      more="$(jq -r '(.more // 0)' "$tmpjson" 2>/dev/null || echo 0)"
      rm -f "$tmpjson"
      page=$((page+1))
      [[ "$more" == "1" ]] || break
  done

  if [[ "$SHOW_NODESTORE_PAGE_SUMMARY" == "yes" ]]; then
    echo "  NodeStore totals: pages=$pages  seen=$total_seen  new=$total_new  existing=$total_existing"
  fi
}
  ingest_remote_nodestore_to_db() {
    [[ "${HARVEST_REMOTE_NODESTORE:-no}" == "yes" ]] || return 0

    local ruser="${REMOTE_NODESTORE_USER:-mbhillrn}"
    local hosts_raw="${REMOTE_NODESTORE_HOST:-192.168.4.102}"

    # Accept: single "192.168.4.102" OR comma list "192.168.4.110,192.168.4.102"
    # Normalize: commas -> spaces, remove spaces around tokens, collapse repeats
    hosts_raw="${hosts_raw//,/ }"
    # shellcheck disable=SC2206
    local hosts=( $hosts_raw )

    # If operator accidentally entered blanks/commas only, do nothing safely
    if (( ${#hosts[@]} == 0 )); then
      return 0
    fi

    : "${PHASE4_NEW_HOSTS_FILE:=}"
    if [[ -n "${PHASE4_NEW_HOSTS_FILE:-}" && ! -f "$PHASE4_NEW_HOSTS_FILE" ]]; then
      : >"$PHASE4_NEW_HOSTS_FILE"
    fi

    local rhost
    for rhost in "${hosts[@]}"; do
      [[ -n "${rhost//[[:space:]]/}" ]] || continue

      print_section "Remote NodeStore Harvest (${ruser}@${rhost})"

      local page=0 more=1
      : "${SHOW_NODESTORE_PAGE_SUMMARY:=no}"
      : "${SHOW_NODESTORE_IPS:=no}"

      local pages=0 total_seen=0 total_new=0 total_existing=0

      while :; do
        if [[ "${SHOW_NODESTORE_PAGE_NUMBERS:-no}" == "yes" ]]; then
          printf "${C_DIM}  Fetching remote page %s...${C_RESET}" "$page"
        fi

        local tmpjson="$TMPDIR/harvest.remote_nodestore.${rhost}.$$.p${page}.json"

        # Capture JSON on remote host to a temp file, then print it (prevents broken pipe + partial output).
        # Uses sudo -n (no password prompt). Requires remote sudoers to allow cjdnstool.
        ssh -o BatchMode=yes -o ConnectTimeout=10 "${ruser}@${rhost}" "bash -lc '
          tmp=/tmp/nodestore_p${page}.\$\$.json
          sudo -n cjdnstool cexec NodeStore_dumpTable --page=${page} >\"\$tmp\"
          cat \"\$tmp\"
          rm -f \"\$tmp\"
        '" >"$tmpjson" 2>/dev/null

        if [[ ! -s "$tmpjson" ]]; then
          rm -f "$tmpjson" 2>/dev/null || true
          [[ "${SHOW_NODESTORE_PAGE_NUMBERS:-no}" == "yes" ]] && echo " ${C_GRAY}failed${C_RESET}"
          break
        fi

        # Stop if this page has zero addresses
        local rt_len
        rt_len="$(jq '.routingTable | length' "$tmpjson" 2>/dev/null || echo 0)"
        if [[ "$rt_len" =~ ^[0-9]+$ ]] && (( rt_len == 0 )); then
          rm -f "$tmpjson" 2>/dev/null || true
          break
        fi

        local page_seen=0 page_new=0 page_existing=0
        local ipsfile="$TMPDIR/harvest.remote_nodestore.${rhost}.$$.p${page}.ips"
        jq -r '.routingTable[]? | .ip // empty' "$tmpjson" >"$ipsfile" 2>/dev/null || : >"$ipsfile"

        local page_new_file page_old_file
        page_new_file="$TMPDIR/harvest.remote_nodestore.${rhost}.$$.p${page}.new"
        page_old_file="$TMPDIR/harvest.remote_nodestore.${rhost}.$$.p${page}.old"
        if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
          : >"$page_new_file"
          : >"$page_old_file"
        fi

        while IFS= read -r ip; do
          host="$(cjdns_host_from_maybe_bracketed "$ip")"
          [[ -n "$host" ]] || continue
          page_seen=$((page_seen+1))

          now="$(date +%s)"
          inserted="$(sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO master(host, first_seen_ts, last_seen_ts, source_flags) VALUES('$host',$now,$now,'remote_nodestore'); SELECT changes();")"

          if [[ "${inserted:-0}" == "1" ]]; then
            page_new=$((page_new+1))
            if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
              printf '%s
' "$host" >>"$page_new_file"
            fi
            if [[ -n "${PHASE4_NEW_HOSTS_FILE:-}" ]]; then
              printf '%s
' "$host" >>"$PHASE4_NEW_HOSTS_FILE"
            fi
          else
            page_existing=$((page_existing+1))
            if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
              printf '%s
' "$host" >>"$page_old_file"
            fi
            db_upsert_master "$host" "remote_nodestore"
          fi
        done <"$ipsfile"
        rm -f "$ipsfile" 2>/dev/null || true

        pages=$((pages+1))
        total_seen=$((total_seen+page_seen))
        total_new=$((total_new+page_new))
        total_existing=$((total_existing+page_existing))

        if [[ "$SHOW_NODESTORE_IPS" == "yes" ]]; then
          printf "      ${C_LIGHT_GRAY}Already harvested:${C_RESET}
"
          if [[ ! -s "$page_old_file" ]]; then
            echo "        (none)"
          else
            while IFS= read -r addr; do
              printf "        ${C_LIGHT_GRAY}• %s${C_RESET}
" "$addr"
            done <"$page_old_file"
          fi

          echo
          printf "      ${C_DULL_RED}Unharvested:${C_RESET}
"
          if [[ ! -s "$page_new_file" ]]; then
            echo "        (none)"
          else
            sed 's/^/        • /' "$page_new_file" | sed 's/$/ (FOUND NEW!!)/'
          fi

          if (( page_new > 0 )); then
            printf "    ${C_LIGHT_RED}summary: rt_len=%s  seen=%s  new=${C_BRIGHT_RED}%s${C_RESET}${C_LIGHT_RED}  existing=%s${C_RESET}
" "$rt_len" "$page_seen" "$page_new" "$page_existing"
          else
            printf "    ${C_LIGHT_RED}summary: rt_len=%s  seen=%s  new=%s  existing=%s${C_RESET}
" "$rt_len" "$page_seen" "$page_new" "$page_existing"
          fi
        fi

        more="$(jq -r '(.more // 0)' "$tmpjson" 2>/dev/null || echo 0)"
        rm -f "$tmpjson" 2>/dev/null || true
        page=$((page+1))
        [[ "$more" == "1" ]] || break
      done

      if [[ "$SHOW_NODESTORE_PAGE_SUMMARY" == "yes" ]]; then
        echo "  Remote NodeStore totals (${rhost}): pages=$pages  seen=$total_seen  new=$total_new  existing=$total_existing"
      fi
    done
  }

run_ingest() {
  log_info "Phase 3 ingest run (DB write; no onetry)."
  db_init_schema
  echo
  echo "DB counts (before):"
  db_counts

  ingest_core_peers_to_db
  ingest_addrman_cjdns_to_db
  ingest_nodestore_to_db
  ingest_remote_nodestore_to_db
  echo
  echo "DB counts (after):"
  db_counts
}

# ----- Phase 4: attempt + verify onetry (DB write) -----
  # v5: optional Frontier Expansion (adds discovered fc addrs into master before candidate selection)

core_cjdns_connected_hosts() {
  # Prints one host per line (lowercase), cjdns peers only, normalized:
  #   - [fc..]:port => fc..
  #   - bare fc.. (including 8-hextet ending in digits) => untouched
  local peers
  peers="$(run_cmd_capture_json "getpeerinfo" bash -lc "$CLI getpeerinfo")" || return 1

  echo "$peers" \
    | jq -r '.[] | select(.network=="cjdns") | .addr' \
    | while IFS= read -r raw; do
        cjdns_host_from_maybe_bracketed "$raw"
      done \
    | sort -u
}

db_attempt_begin() {
  local host="${1,,}"
  local now; now="$(date +%s)"
  sqlite3 "$DB_PATH" <<SQL >/dev/null
INSERT INTO attempts(host, last_attempt_ts, attempt_count, last_result, last_fail_ts, consecutive_fail)
VALUES ('$host', $now, 1, 'attempt', NULL, 0)
ON CONFLICT(host) DO UPDATE SET
  last_attempt_ts=$now,
  attempt_count=attempt_count+1,
  last_result='attempt';
SQL
}

db_attempt_result_ok() {
  # Usage: db_attempt_result_ok host [reason]
  local host="${1:-}"
  [[ -n "$host" ]] || return 0
  host="${host,,}"
  local ts
  ts="$(date +%s)"

  # Mark OK. Do NOT bump attempt_count here (db_record_attempt already did).
  sqlite3 "$DB_PATH" <<SQL >/dev/null 2>&1 || true
INSERT INTO attempts(host, last_attempt_ts, attempt_count, last_result, consecutive_fail, cooldown_until_ts)
VALUES ('$host', $ts, 1, 'ok', 0, NULL)
ON CONFLICT(host) DO UPDATE SET
  last_attempt_ts    = excluded.last_attempt_ts,
  last_result        = 'ok',
  consecutive_fail   = 0,
  cooldown_until_ts  = NULL;
SQL
}

db_attempt_result_fail() {
  local host="${1,,}"
  local now; now="$(date +%s)"

  # bump fail counters
  sqlite3 "$DB_PATH" <<SQL >/dev/null
INSERT INTO attempts(host, last_attempt_ts, attempt_count, last_result, last_fail_ts, consecutive_fail)
VALUES ('$host', $now, 0, 'fail', $now, 1)
ON CONFLICT(host) DO UPDATE SET
  last_result='fail',
  last_fail_ts=$now,
  consecutive_fail=consecutive_fail+1;
SQL
}

is_host_connected_in_core() {
  # Usage: is_host_connected_in_core host
  # Return 0 iff host currently appears among Core's connected peers (network=="cjdns").
  #
  # Avoid piped while-loop + exit patterns (subshell). Normalize then exact-match.

  local host="${1,,}"
  local peers

  peers="$(run_cmd_capture_json "getpeerinfo" bash -lc "$CLI getpeerinfo")" || return 1

  if echo "$peers" \
      | jq -r '.[] | select(.network=="cjdns") | .addr' \
      | while IFS= read -r raw; do cjdns_host_from_maybe_bracketed "$raw"; done \
      | grep -qxF "$host"
  then
    return 0
  fi
  return 1
}

verify_onetry_core() {
  # Usage: verify_onetry_core host
  local host="${1,,}"

  if [[ "$ONETRY_VERIFY_MODE" == "delay" ]]; then
    sleep "${ONETRY_VERIFY_DELAY_SEC}"
    if is_host_connected_in_core "$host"; then
      return 0
    fi
    return 1
  fi

  # default: wait/poll
  local timeout="${ONETRY_VERIFY_TIMEOUT_SEC}"
  local end=$((SECONDS + timeout))
  while (( SECONDS < end )); do
    if is_host_connected_in_core "$host"; then
      return 0
    fi
    sleep 1
  done
  return 1
}

should_inline_confirm() {
  [[ "${ONETRY_CONFIRM_MODE:-batch}" == "inline" ]] && return 0
  return 1
}

attempt_one_host() {
  # Usage: attempt_one_host host
  # In INLINE mode: verify per-host and write confirmed/attempt result immediately.
  # In BATCH mode: dispatch onetry only; confirmation+attempt results are handled after post-snapshot.
  local host="${1,,}"

  # informational ping only (MUST NOT gate onetry)
  # Use cjdns-aware ping (RouterModule_lookup + SwitchPinger_ping).
  # NOTE: Many cjdns hosts do not answer ICMPv6, so ping6 is not reliable here.
  if [[ "${PING_ENABLE:-${ENABLE_PING:-no}}" == "yes" ]]; then
    timeout_ms=$(( (${PING_TIMEOUT_SEC:-1}) * 1000 ))

    lookup_json="$(/usr/local/bin/cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec RouterModule_lookup --address="$host" 2>/dev/null || true)"
    lookup_res="$(printf '%s' "$lookup_json" | sed -n 's/.*"result"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p')"
    path="${lookup_res##*@}"

    if [[ -n "${path:-}" && "$path" != "$lookup_res" ]]; then
      pong_json="$(/usr/local/bin/cjdnstool -a "${CJDNS_ADMIN_ADDR:-127.0.0.1}" -p "${CJDNS_ADMIN_PORT:-11234}" -P NONE cexec SwitchPinger_ping --path="$path" --timeout="$timeout_ms" 2>/dev/null || true)"
      if printf '%s' "$pong_json" | grep -q '"result"[[:space:]]*:[[:space:]]*"pong"'; then
        printf "    Ping: "
        status_pong_ok
        echo
      else
        printf "    Ping: "
        status_pong_fail
        echo
      fi
    else
      # fallback: ICMPv6 (often blocked on cjdns hosts)
      if ping6 -c 1 -W "${PING_TIMEOUT_SEC}" "$host" >/dev/null 2>&1; then
        printf "    Ping: "
        status_pong_ok
        echo
      else
        printf "    Ping: "
        status_pong_fail
        echo
      fi
    fi
  fi

  db_attempt_begin "$host"
  $CLI addnode "$host" onetry >/dev/null 2>&1 || true

  if should_inline_confirm; then
    if verify_onetry_core "$host"; then
      printf "    Core onetry: "
      status_connected
      echo
      db_upsert_confirmed "$host"
      db_attempt_result_ok "$host"
      return 0
    else
      printf "    Core onetry: "
      status_not_seen
      echo " (within verify window)"
      db_attempt_result_fail "$host" "not_seen"
      return 1
    fi
  else
    printf "    Core onetry: "
    status_dispatched
    echo " (batch confirm after scan)"
    # do not set ok/fail here; batch confirm will do it using post-pre diff
    return 0
  fi
}

pick_candidates_from_db() {
  # Usage: pick_candidates_from_db limit
  # Prints hosts (not confirmed), one per line.
  # limit=0 => no cap
  local limit="${1:-0}"
  [[ "$limit" =~ ^[0-9]+$ ]] || limit=0

  local now; now="$(date +%s)"
  local limit_sql=""
  if (( limit > 0 )); then
    limit_sql=" LIMIT $limit"
  fi

  sqlite3 -noheader -batch "$DB_PATH" "
SELECT m.host
FROM master m
LEFT JOIN confirmed c ON c.host=m.host
LEFT JOIN attempts a ON a.host=m.host
WHERE c.host IS NULL
ORDER BY m.last_seen_ts DESC
$limit_sql;
"
}

pick_confirmed_candidates_from_db() {
  # Usage: pick_confirmed_candidates_from_db limit
  # Returns confirmed hosts (oldest last_confirmed first), skipping cooldown if present.
  # limit=0 => no cap
  local limit="${1:-0}"
  [[ "$limit" =~ ^[0-9]+$ ]] || limit=0

  local now; now="$(date +%s)"
  local limit_sql=""
  if (( limit > 0 )); then
    limit_sql=" LIMIT $limit"
  fi

  sqlite3 "$DB_PATH" <<SQL
.headers off
.mode list
SELECT c.host
FROM confirmed c
LEFT JOIN attempts a ON a.host=c.host
ORDER BY c.last_confirmed_ts ASC
$limit_sql;
SQL
}

ingest_confirmed_sources() {
  echo
    print_section "Confirmed Sources"

  # 1) Addrman cjdns (count=0 means ALL; you confirmed this is required)
  local j total
  j="$(run_cmd_capture "addrman_cjdns" bash -lc "$CLI getnodeaddresses 0 cjdns")" || j="[]"
  total="$(echo "$j" | jq 'length' 2>/dev/null || echo 0)"
  echo "  addrman_cjdns_total=$total"
  if (( total > 0 )); then
    echo "$j" | jq -r '.[]? | .address' | while IFS= read -r host; do
      host="${host,,}"
      [[ -n "$host" ]] || continue
      db_upsert_confirmed "$host"
      db_upsert_master "$host" "addrman"
    done
  fi

  # 2) Currently connected Core peers (cjdns) - REUSE pre-snapshot
  local pre_n
  pre_n="$(printf '%s\n' "$pre" | sed '/^$/d' | wc -l | awk '{print $1}')"
  echo "  core_connected_now=$pre_n"
  if (( pre_n > 0 )); then
    printf '%s\n' "$pre" | sed '/^$/d' | while IFS= read -r host; do
      host="${host,,}"
      [[ -n "$host" ]] || continue
      db_upsert_confirmed "$host"
      db_upsert_master "$host" "connected_now"
    done
  fi
}

core_snapshot_to_file() {
  # Writes current Core cjdns peers (hosts only) to a file, sorted unique.
  local out_file="${1:?out_file}"
  if ! core_cjdns_connected_hosts >"$out_file"; then
    return 1
  fi
  # Ensure normalized/sane (no blanks)
  sed -i '/^$/d' "$out_file"
  sort -u -o "$out_file" "$out_file"
}

core_wait_for_post_snapshot() {
  # Poll Core peers until stable OR changed (depending on what happens first).
  # Args: pre_file post_file max_seconds
  local pre="${1:?pre}"
  local post="${2:?post}"
  local max_s="${3:?max_s}"

  local start="$SECONDS"
  local last="$TMPDIR/cjdns_last.$$"
  rm -f "$last"
  : >"$last"

  local stable=0
  while (( SECONDS - start < max_s )); do
    if ! core_snapshot_to_file "$post"; then
      return 1
    fi

    # if identical to last sample, count stability; else reset stability counter
    if cmp -s "$post" "$last" 2>/dev/null; then
      stable=$((stable+1))
    else
      stable=0
      cp -f "$post" "$last"
    fi

    # If we've stabilized for 2 consecutive polls, stop early.
    if (( stable >= 2 )); then
      rm -f "$last"
      return 0
    fi

    sleep 1
  done

  rm -f "$last"
  return 0
}
